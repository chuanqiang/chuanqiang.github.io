<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七弦桐</title>
  <subtitle>以梦为马，随处可栖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chuanqiang.github.io/"/>
  <updated>2017-08-20T10:14:32.000Z</updated>
  <id>http://chuanqiang.github.io/</id>
  
  <author>
    <name>七弦桐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第九周 - 一周大事件</title>
    <link href="http://chuanqiang.github.io/2017/08/20/week-news/"/>
    <id>http://chuanqiang.github.io/2017/08/20/week-news/</id>
    <published>2017-08-20T08:40:17.000Z</published>
    <updated>2017-08-20T10:14:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于在官网上购买了mac book pro 2017 15寸 512G 版本，不出意外的话下周到货。剩下的就是幸福的等待了。</p>
<a id="more"></a>
<p><img src="http://oeckzejn4.bkt.clouddn.com/blog/170820/HDkml6kGc2.png?imageslim" alt="等待苹果官网审核"></p>
<p>关于这次的剁手，其实远在大学时代就已经在心里埋下了十分茂密的草。高三暑假，读了乔布斯传，了解了苹果这家伟大的公司及其旗下伟大的那些产品。那句『thank different』至今是许多人的座右铭。</p>
<blockquote>
<p>致疯狂的人：<br>致疯狂的人。他们特立独行。他们桀骜不驯。他们惹是生非。他们格格不入。他们用与众不同的眼光看待事物。他们不喜欢墨守成规。他们也不愿安于现状。你可以认同他们，反对他们，颂扬或是诋毁他们。但唯独不能漠视他们。因为他们改变了寻常事物。他们推动人类向前迈进。或许他们是别人眼里的疯子，但他们却是我们眼中的天才。因为只有那些疯狂到以为自己能够改变世界的人……才能真正改变世界。</p>
</blockquote>
<p>苦于学生时代的拮据，没能入手。如今终于有了购买的能力，借着这次官网有教育优惠的东风，想狠狠的剁手一把，直接搞顶配。期间也有多次犹豫，在各种代购和官网间犹豫，在版本配置上徘徊。最终狠了狠心，顶着肉疼决定剁手15寸的顶配。『天生我材必有用，千金散尽还复来』，两万多固然是一笔不小的投入，但对于生产力的投资所带来的收益相信更是不可估量的。有了装备加持，更要要求自己写出更优雅的代码。</p>
<p>公司在周五举行了小型的生日趴，也相当于下午茶活动了。每个月过生日的同事选择某一天一块庆祝，放音乐、点蜡烛、吃蛋糕。既增加了公司认同感，又缓解了员工的工作压力，不失为一个好办法。公司大的福利待遇很一般，但是小福利不断，比如生日趴啦，发送零食啦，免费领抽纸、鼠标垫等小物品啦，免费加班餐啦，每周五下午体育馆的预定等，虽然不是多大的付出，但能然员工感到公司劳动力剥削之外温情的一面。恩，这个套路不错^O^<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170820/j37JC5B2iI.JPG" alt="生日趴"></p>
<p>周六撸了『权利的游戏』第七季第五和第六集，龙母和雪诺被网友戏称为杨过和小龙女，异鬼将要和守夜人正面较量了，夜王真是个大boss，竟然同化出了冰龙。寒冬将至，静等这部伟大的剧接下来讲述的故事。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170820/f664gCdgle.JPG" alt="龙母"><br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170820/bmJaD1Le6D.JPG" alt="夜王"></p>
<p>接下来的一周，继续好好撸代码，争取通勤时间把柴静的『看见』读完。一直想写一个关于优质软件分享的系列，手机 APP 和 Windows 下的，希望下一周可以完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于在官网上购买了mac book pro 2017 15寸 512G 版本，不出意外的话下周到货。剩下的就是幸福的等待了。&lt;/p&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="大事件" scheme="http://chuanqiang.github.io/tags/%E5%A4%A7%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>第八周 - 仗剑走天涯</title>
    <link href="http://chuanqiang.github.io/2017/08/13/to%20wander%20with%20a%20sword/"/>
    <id>http://chuanqiang.github.io/2017/08/13/to wander with a sword/</id>
    <published>2017-08-13T15:32:36.000Z</published>
    <updated>2017-08-14T02:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>曾梦想仗剑走天涯<br>看一看世界的繁华<br>年少的心总有些轻狂<br>如今已四海为家</p>
</blockquote>
<a id="more"></a>
<p>这周过的，怎么说呢，此起彼伏。项目只是一个小版本的迭代，由于一开始产品那边有一些需求没有确定，所以开始的开发任务很是轻松，慢悠悠的捣鼓新 IED 工具的使用，但是到了上线当天的下午，突如其来的需求，有点让我措手不及。没办法，加急改呗。生活就是这样，总是不按常理出牌，你永远不知道在峰回路转处埋伏的是惊喜还是惊吓。</p>
<p>在大学之前，我从没有想过自己会从事程序开发的工作，那时候想的是当个人民教师，教书育人，因为讲台上的老师很神气啊，或者当个医生，救死扶伤。后来到了大学，开始越来越迷茫，我相信大多数人那个时候都迷茫，一边是热血青春，荷尔蒙爆棚，另一边“英雄无用武之地”，不知道到哪里去发挥自己的光和热，所以只能挥汗于球场，或奋战于游戏，或沉溺于情爱，或在酒杯碰撞间觥筹交错了。之后开始了解和学习编程，当时觉得这东西玩智商，能做别人不懂的事情，很酷； 一些程序员都是在空调房里敲敲键盘就有可能冷不丁改变了世界，像马化腾、扎克伯格，并且还坚信，我能让这个世界变得好了一点点。后来工作之后发现，理想很丰满，显示忒他妈骨感，都瘦的柴了。抱怨的不想说太多，但抛开傲慢与偏见，我依然认为程序员是这个时代里不错的职业。无论程序员自嘲也好，被误解也罢，虽然普遍给人衣着邋遢、气质差的印象，但不可否认的是，程序员依旧是互联网时代的宠儿。</p>
<p>作为一个程序员，除去加班和职业病的隐患，有时候一个人闷头撸代码还挺享受的。不会考虑外界的纷纷扰扰，没有了交际的繁杂，只要按时保质的完成你的工作，没人催你，更没人盯着你、管着你。你只需把全部精力放在一尺见方的屏幕上，指尖在茶轴的机械键盘上光影闪烁，神经末梢感触着键程的起伏和段落感，同样也感触着内心的思考和表达。抽象的思考通过手指的舞蹈伴随键盘敲击的清脆，在四四方方的屏幕上刻画出了具体的影像。有时，障碍重重，debug了n多次，头绪好像都见了周公，键盘的声音都充满了代码块战死沙场的悲怆。有时一路的风生水起，披荆斩棘，指尖下行云流水，一路的悦耳叮咚。</p>
<p>如果把写代码比做金庸笔下刀光剑影的武侠世界，那一件趁手锋利的武器，必是每个侠客梦寐以求的梦想， 剑气纵横三万里，一剑光寒十九州，好的武器能助你在代码的武侠世界里挥刀斩棘，剑出风惊。对于我来说，这把梦寐的利器当然就是 Mac Book Pro 了。其实从大学开始，就对苹果的产品入迷，但当时作为一个穷学生，也只有仰之弥高了。如今工作之后，具备了条件，当然是时不我待，准备入手。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170813/L16mlDD2IF.png?imageslim" alt="mark"></p>
<p>当然，对于入手 Mac Book Pro ，我是做过思考的。平心而论，首先这款产品，并不具有性价比，同样的价格可以买两台性能不错的 Windows电脑了。其次，从Window迁移到 mac os x 系统，有一定的学习成本和割舍，毕竟系统有差异，许多软件不具备跨平台，意味着你要告别一些软件，开始一些新的软件的探索。另外，你要步入苹果封闭的生态圈，可能你以后购买产品时都被圈养在这个圈里了。你的苹果设备上有许多软件，这些软件优质但只有ios和mac版，你的用户数据都存储在这些软件上，你的用户习惯已经养成，这个时候，你已经被牢牢的栓在了苹果的生态圈里，你的下一款设备毫无疑问是苹果。是的，你已经无法逃离。说的挺恐怖悲观的，但是，我还是想一头扎进去，并在心里默念：apple，俘获我吧。原因很简单:信仰，颜值，续航，屏幕，优秀的工业设计，稳定流畅的系统，生态下的优质软件，和其他苹果设备的无缝连接。。。当然更深层次的优劣必须长期使用后才能得出，凡是不以体验为结果的测评都是耍流氓。</p>
<p>我认为当下最好的投资，就是投资自己。我一直坚信成长比成功重要。所以我会毫不犹豫的选择mac，因为投资生产力准没错。</p>
<p>期待着我和它仗剑走天涯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;曾梦想仗剑走天涯&lt;br&gt;看一看世界的繁华&lt;br&gt;年少的心总有些轻狂&lt;br&gt;如今已四海为家&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="mac" scheme="http://chuanqiang.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>第七周 - 软件之我见</title>
    <link href="http://chuanqiang.github.io/2017/08/06/soft/"/>
    <id>http://chuanqiang.github.io/2017/08/06/soft/</id>
    <published>2017-08-06T14:31:07.000Z</published>
    <updated>2017-08-06T14:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知从什么时候开始，我喜欢上了捣鼓软件，无论是手机APP还是PC软件。关注想『少数派』、『数字尾巴』、『小众软件』这些网站，喜欢折腾这些数据和指令的集合体，从陌生到熟悉，欣赏它们的UI设计，看它们的功能实现。在每一个软件中你能感受到开发者的理念，虽然各有美丑，但欣喜于软件在作用于生活后带来的改变，虽然可能很甚微，但总归让枯燥的生活变的不一样和有趣了一些。</p>
<p>有一句关于程序员自我意淫的话，但我依然喜欢叨念:</p>
<blockquote>
<p>程序员改变世界</p>
</blockquote>
<a id="more"></a>
<p>就像知乎上有一段话:</p>
<blockquote>
<p>每当大家觉得格局确定了，总会有那么一两个程序员走出来，翻动那个真正能彻底改变棋盘的子。过去的很多传统行业都经历了从新兴到高速发展再到稳定继而沉闷的各个阶段。如同海上贸易，钢铁，石油，化工，机械，半导体等等。然而互联网和这些如此的不同，以至于经过了快三十年的发展，依然不断涌现出挑战你世界观的产品和概念。</p>
</blockquote>
<p>改变世界或许很困难，但改变自己的生活就容易的多，有时候是一部电影，一本小说，也可能只是一个软件。这周接触到了不同的三款软件，在不同的领域，有不同的作用，但各赋异禀。</p>
<p>第一个是chrome浏览器上的一款插件，叫『Infinity』。它重新定义了新标签页，在极简、美观的前提下，提供了一站式服务的标签页，更好用、更强大、更优雅、更轻松的使用 chrome。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170806/kLm6LD5HAc.png?imageslim" alt="Infinity"></p>
<p>第二个是著名的 IDE 软件 IntelliJ IDEA，从Eclipse 转到这个上面真的不容易，长时间使用养成的习惯很难改变，但既然下决心『分手』，那就长痛不如短痛吧。耐下心来慢慢摸索，现在渐渐适应了Idea的使用，但仍感觉Idea相比Eclipse太过厚重，界面也不简约，但厚重在另一方面也就意味着功能强大，相信顺手之后会成为开发过程中的一件利器。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170806/9GLB1jaFAd.png?imageslim" alt="IDEA"></p>
<p>第三个是一款手机游戏——『皇室战争』，是由芬兰游戏公司Supercell所推出的，以《部落冲突》的角色和世界观为原型，加入即时策略、MOBA以及卡牌等元素的手机游戏，于2016年1月4日在App Store发布。在游戏中，玩家需通过不断的开启宝箱来获取卡片的方式来增强自己的战斗力，进而与其他在线的玩家进行匹配战斗。随着奖杯提升，开启不同场地的竞技场。这款游戏极具新意的融合了卡牌、塔防多种元素的对抗竞技玩法，具有上手容易精通难的特点，总之是一款很不错的游戏，可以打发无聊的琐碎时间。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170806/BHK3FH3iL3.jpg?imageslim" alt="皇室战争"></p>
<p>我们与互联网交互其实大都是通过软件实现的，无论是浏览器还是手机APP，他们是我们与数据交互的入口和平台，他们体验的好坏直接影响了你对于所处的互联网生活的感受是好还是坏。其实通过体验不同的软件，你会发现好的工具，一定是『有用』、『好用』和『耐用』的。</p>
<p>所谓有用是说对于我们用户来说首先得是以需求为先导的，华而不实的软件无法融入到你的生活，比如我有社交的需求，那我就选择了微信，我有写东西的需求，那我可能会选择『MarkEditor』，那我写完还想分享给别人，那我可能会选择『简书』，想要再PC上快速搜索东西，那我选择了『everything』，等等这些软件都是抓住了需求点的，有一款绘画类软件做的特别好，但是我对画画不感兴趣，那也不是我的菜，不会下载到手机上的。找对需求是你使用软件的第一步，当然，纯粹为了折腾，体验完删掉了，这种的不算。</p>
<p>其次是好用，同质化的软件那么多，凭什么你会脱颖而出，只有优秀的用户体验，简约美观的UI 才能抓住用户的心。稍后读类的软件有很多，比如pocket、Instapaper ，但我最后还是选择了『收趣』，就是因为本土化，用起来顺手，交互方便，并且颜值高。我的手机上文本编辑类软件有好多，ios自带的备忘录，Bear、有道云笔记，简书、wps，但平时写东西就喜欢用『Bear』，原因很简单，好看呗，写东西的时候心情舒服，左右滑动为主的交互简洁方便。</p>
<p>最后是耐用。可能会问，软件又不是实物，怎么存在耐不耐用的问题呢？当一款软件你长久的使用后，你会保留在这款软件上你的数据，包括操作习惯的设置，用户保存的数据。这些数据是这些软件流动的血液，是他们的灵魂。没有了数据，他们什么都不是。其实推此及彼，不只是在软件，整个互联网时代最重要的就是数据，是互联网公司的立命之本。像阿里巴巴、腾讯为什么市值这么高，肯定不是固定资产，说白了就是数据，他们都是靠用户的数据活着的，用户也是用因为这些数据才能网上购物、微信聊天的。再回到软件，一款软件怎么才能耐用、耐糙呢？关键是数据的保存。软件是建立在平台上的，不论是手机、电脑还是平板，它得有一个硬件来承载。软件在互联网上的寿命可以无穷尽，但是硬件不行，当你更换了硬件设备之后，如何还能无缝的启用你的数据信息，这是软件耐用的本质，因为它会延长我们对一款软件的使用时间，也就是提高了一款软件对于你而言的寿命。有两个条件：1.云存储。2.跨平台。云存储提高了软件的跨时间的能力，而跨平台加上了软件的跨空间的能力。这样用户无论迁移到哪一个平台，都能毫不费力的『复活』你的软件，也提高了一款软件作为商品的受众人群。</p>
<p>综上，我觉得，一款软件只有具备了以上三个特性：有用，好用，耐用，才是一款称得上优秀的软件。</p>
<p>生命不息，折腾不止。折腾软件，也折腾生活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知从什么时候开始，我喜欢上了捣鼓软件，无论是手机APP还是PC软件。关注想『少数派』、『数字尾巴』、『小众软件』这些网站，喜欢折腾这些数据和指令的集合体，从陌生到熟悉，欣赏它们的UI设计，看它们的功能实现。在每一个软件中你能感受到开发者的理念，虽然各有美丑，但欣喜于软件在作用于生活后带来的改变，虽然可能很甚微，但总归让枯燥的生活变的不一样和有趣了一些。&lt;/p&gt;
&lt;p&gt;有一句关于程序员自我意淫的话，但我依然喜欢叨念:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序员改变世界&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="软件" scheme="http://chuanqiang.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>第六周 - 坝上草原旅行日志</title>
    <link href="http://chuanqiang.github.io/2017/07/29/bashangGrassland/"/>
    <id>http://chuanqiang.github.io/2017/07/29/bashangGrassland/</id>
    <published>2017-07-29T10:42:30.000Z</published>
    <updated>2017-08-06T13:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>生活有时候像一座牢笼，把我们困在一个狭小的范围内，从家到公司的距离经常是我们每天出行距离的端点。生活满是纷纷扰扰的琐碎，我们已经很少抬头眺望一下远方的景色了。</p>
<a id="more"></a>
<p>傅真在『最好金龟换酒』中有一针见血的描述:</p>
<blockquote>
<p>一年又一年，时间就这样从键盘间溜走。回首时觉得时光飞逝，可是落实到每一天又好似度日如年——每天都望眼欲穿地盼望着周末，盼望着假期，而这一姿态本身又让我觉得心酸而惶惑，仿佛是在盼望着时间的飞速流逝，盼望着自己的生命早日终结。</p>
</blockquote>
<p>我虽然没有这么悲观的情绪，但最近加班赶项目也确实挺累的，心理和身体上都需要来一个『诗和远方』的洗礼了。老板也是体贴入微啊，为我们产品中心的人组织了一个周末两天的小团建，让我们好好放松一下。地点是丰宁坝上草原，我从没有见过草原，只在『天苍苍，野茫茫，风吹草地现牛羊』的诗句中竭力想象过。这次终于可以亲眼看看天似穹庐，笼盖四野是什么样子了。</p>
<p>先在网上搜了下坝上草原的资料:</p>
<blockquote>
<p>坝上草原主要位于河北省境内，特指由草原陡然升高而形成的地带，又因气候和植被的原因形成的草甸式草原。张家口以北100公里处到承德以北100公里处，统称为坝上草原地区。<br>坝上草原是坝上高原的重要组成部分，位于内蒙古高原与大兴安岭南麓的接壤地带。平均海拔高度1500—2100米，平均气温约1.4-5度，西起张家口市的张北县、尚义县，康保县、中挟沽源县、丰宁县，东至承德市围场县。<br>坝上草原主要又分为围场坝上(木兰围场)、丰宁坝上、张北坝上和草原天路等区域组成，是内蒙古高原的重要组成部分，其中木兰围场县-乌兰布统大草原最为美丽，丰宁坝上草原位于北京正北的河北省丰宁满族自治县，是离北京最近的天然草原，又名“京北第一草原”。<br>坝上草原属温带季风气候，冬季漫长，夏季无暑，清凉宜人，7月平均气温摄氏24度，水草丰茂、富饶美丽、冬夏分明、晨夕各异</p>
</blockquote>
<p>以下是两天的旅行日志，中间穿插了些琐碎的描述和想法。</p>
<hr>
<h2 id="坝上草原旅行日志"><a href="#坝上草原旅行日志" class="headerlink" title="坝上草原旅行日志"></a>坝上草原旅行日志</h2><blockquote>
<p>时间：2017.7.22-2017.7.23<br>天气：阴转小雨<br>地点：河北坝上草原  </p>
</blockquote>
<ul>
<li>2017.7.21 一天处于兴奋中。<ul>
<li>看电脑屏幕的代码都变成了茫茫的大草原。下班先去了体育馆和同事打了球，回家后收拾要带的东西。看了攻略，带着长袖衣服，因为得知住酒店，没有带洗漱用品，后来才知道完全被导游的失误给坑了。最好带着驱蚊的和换洗鞋袜。</li>
</ul>
</li>
<li>2017.7.22 早八点于公司乘坐大巴车出发。<ul>
<li>不用担心早餐问题，因为公司的人事姐姐们很体贴的帮我们准备好了早餐(此处有赞)。汽车开动，吃饱喝足，补了个早觉。</li>
</ul>
</li>
<li>依次经过怀柔，丰宁，河北高速，千松坝，京北第一天路。<ul>
<li>睡醒一觉，一看外面，卧槽，不是做梦吧。这大片的绿色，葱葱郁郁，巍峨的高山近在咫尺，沿途高山流水，风景俊秀。由于刚下过小雨，山顶云雾缭绕，颇有仙境之感。我贪婪的观赏者外面的美景，时间好像被定格，忘记了一切，只剩下这大自然的美丽景色了。</li>
<li>在崇山峻岭间令人真正感觉到了自己是天空和大地的臣民。你能敏锐地察觉到天地间的每一点变化——天色的明暗，云朵的移动，空气的湿度，泥土的气息，风的方向，植物的清香——全都令人感怀至深。只有在这样的时刻，世界才会放慢速度在心弦上跑过，奏出丰富的乐声。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/HKkD0hgeAg.JPG" alt="mark"><br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/898kjbf2H3.jpg?imageslim" alt="mark"></li>
</ul>
</li>
<li>河北高速两侧，低丘草原，马儿驻足吃草。<ul>
<li>再往前，山川渐渐变矮，出现了丘陵和草原，但不变的，仍旧是满目的苍翠，这大片大片的绿色像是上帝泼洒上去的，山壑间更是浓重，仿佛绿色在流动汇集。随着汽车前行，高速路两旁出现了驻足吃草的马儿，第一次见到在自然环境下惬意的马儿，他们像是这自然中的精灵，与天地相容，点缀着苍茫的美景。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/dgkI6h7Cbf.jpg?imageslim" alt="mark"></li>
</ul>
</li>
<li>路途间穿过许多条长长的隧道</li>
<li>于下午一点多在『草原寒舍度假酒店』，下榻并吃午餐。<ul>
<li>店如其名——『寒舍』，住的一般，两人一间，竟然没有洗漱用品，这着实在意料之外，自己也没有带，导游也没有提这个，感觉这是他的失职，算了，入乡随俗，看风景就好。午餐做的还好，说不上丰盛，但食材都是当地纯天然的，算是纯正的农家饭吧。其中红烧鱼做的比较鲜嫩，红烧肉酸菜豆腐不错，红烧肉肥而不腻。住宿的地方在二楼，屋外的风景很好，窗外是低缓的小丘，举目皆绿，视野开阔，雨后苍翠的丘陵延绵起伏。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/AKCkIC8CHC.png?imageslim" alt="mark"></li>
</ul>
</li>
<li>小雨还在淅淅沥沥，午饭后小憩休息一下。</li>
<li>下午三点，整装出发。</li>
<li>到达草场，因为下午有许多泥泞。看了『闪电湖』，听他们说现在高处看湖的形状酷似闪电而得名。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/adC8cfmfK3.JPG" alt="mark"><ul>
<li>是有些失望的，因为我想象中的草原最起码要一望无垠，并且一马平川的那种，但在这里远处是有些低缓的丘陵的，草原的面积也没有那么大。不过风景总归是挺美的。从繁忙的都市来到这里，有种恍如隔世的错觉。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/BIDb8CC4Fm.JPG" alt="mark"><br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/807dHgD8hH.JPG" alt="mark"></li>
</ul>
</li>
<li>五点，返程住处，路经『大汉行宫』，辉煌壮丽，驻足拍照。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/b24mgcbg87.JPG" alt="mark"><br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/flj2Ihh9mE.JPG" alt="mark"></li>
<li>晚上，篝火晚宴，吃烤全羊<ul>
<li>晚上是重头戏，出来放松，看风景是一部分，另一部分就是『吃喝玩乐』。现杀的膘肥体壮的小绵羊，提前用葱段、姜片、花椒、大料、精盐搓擦入味，将羊尾用铁签别入腹内，胸部朝上，四肢用铁钩挂住皮面，刷上油。不时将白条羊在火上左右翻转，在炭火的熏烤下，阵阵香气飘来，一直烤到表面金红油亮，香味喷发，外焦里嫩为止。天色渐晚，草原的夜色，朦胧醉人，雨后青草香和烤羊肉的香气扑鼻而来，孔明灯放飞，篝火架起，一闪一闪的火焰给夜色增添了神秘和草原的粗犷。人群在篝火处聚集，动感音乐声起，我们手拉手围着篝火唱歌跳舞，篝火热烈的火焰沸腾着我们默然已久的内心，我们大声歌唱、大声欢笑，此时此刻，每个人都像是天真的孩子。一会，羊肉香气渐浓，烤全羊也好了。我们一手握着啤酒瓶，一手在烤羊架上撕下香嫩的羊肉沾着佐料大口吃着，在这种原始的吃法中体验着草原汉子的粗犷豪迈。篝火晚会持续到凌晨，跃动的篝火和烤羊香一直伴随到我的梦里，沉沉睡去。</li>
</ul>
</li>
<li>2017.7.23，吃过早饭，去附近的『孤山子』上溜达，拍照、看风景。看到山脚的养蜂人，山头上闲适吃草的马，山下大片大片的油菜花。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/0KAGfJ3g62.JPG" alt="mark"></li>
<li>一个意外的惊喜，没赶上大部队去骑马，但是在孤山子碰到一个租马的老头。租了两匹马。<ul>
<li>这些马儿都特别温顺，不用什么护具，也没人管着，我们只要按时归还马匹就行。我们四个围着山脚一边看着风景，一边骑马溜达。当然只是溜达，我也想策马奔腾一下，但是这是我人生的第一次骑马，还是抑制住了这个大胆的想法。近距离的观察马儿这个动物，也不住的感慨，上苍真是偏心啊，对马这种动物如此垂青，赋予了它健美的身躯，优雅的体型，潇洒的鬃毛。骑在马上，有种特别的感觉，可能是因为从未有过的体验而倍显特别吧。掌握好马行走的节奏，抓好马缰，双腿加紧马身，前脚掌踏好马踏，在马背上居高临下，想象着自己是古代骑着马的威风凛凛的大将军。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/Ihe3bLCG85.JPG" alt="mark"><br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/ejGADGi8LB.JPG" alt="mark"></li>
</ul>
</li>
<li>2017.7.22，十二点半，吃过中午饭，收拾返京。</li>
<li>回去一路上，风景更是惊为天人。走盘山公路，从一千八百多米的海拔下去后，竟然出现了短暂的耳朵嗡鸣现象。</li>
<li>回去走京城高速，路过雁西湖，有雁西湖国际会展中心，造型独特。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170729/0hJEdfhI5f.JPG" alt="mark"></li>
<li>由于回去路上堵车，于六点左右到家。</li>
</ul>
<hr>
<p>不知为何，虽然草原的景色旖旎，但回来的一路上并没有对那里有过多的留恋和不舍，反而希望早点回到家，连着wifi，吹着空调吃西瓜。美丽的景色，只有经久不见和难得一见的时候才凸显出她的美。许巍唱『生活不止眼前的苟且，还有诗和远方的田野』，可是诗和远方的田野是在生活的琐碎中酝酿出了发现他们美的眼睛和赞叹他们美的声音的。</p>
<p>在城市中忙忙碌碌的时候，也会想到远方有美丽的景色在等着我们，并且相信下一次相会不会很久。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活有时候像一座牢笼，把我们困在一个狭小的范围内，从家到公司的距离经常是我们每天出行距离的端点。生活满是纷纷扰扰的琐碎，我们已经很少抬头眺望一下远方的景色了。&lt;/p&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第五周 - 夏天</title>
    <link href="http://chuanqiang.github.io/2017/07/16/summer/"/>
    <id>http://chuanqiang.github.io/2017/07/16/summer/</id>
    <published>2017-07-16T15:07:36.000Z</published>
    <updated>2017-07-16T15:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>已经入伏了，天气闷热难耐。所谓入伏，其实就是进入了三伏天，也就是是出现在小暑与处暑之间，是一年中气温最高且又潮湿、闷热的日子。百度百科说，三伏天的『伏』就是指『伏邪』，即所谓的『六邪』（指“风、寒、暑、湿、燥、火”）中的暑邪。</p>
<a id="more"></a>
<blockquote>
<p>2017年三伏天：<br>具体时间：<br>2017年7月12日~2017年7月21日 为初伏 10 天<br>2017年7月22日~2017年8月10日 为中伏 20 天<br>2017年8月11日~2017年8月20日 为末伏 10 天</p>
</blockquote>
<p>有句话叫『装睡的人叫不醒』，但现在这句话有了下文——『你把空调关了试试』。三十多度的炎夏，其实如果是在乡村，不吹空调也是可以忍受的。小时候，晚饭后树下乘凉，吃西瓜，吱悠悠的电风扇，清凉解渴的绿豆汤，是伴随整个夏天的驱暑手段，没有这些，好像夏天也就变得不像夏天了。而在高楼林立，到处都是钢筋混凝土的都市，由于这些材质的比热容特性，再加上城市的热岛效应，如果没有了空调，那将是惨不忍睹。试想如果地铁上没有空调，如果还是早高峰的话。。。所以，家里、地铁上、公司，三个地方空调轮着吹，中午都改成了定外卖，同事以前常寒暄的用语也从『中午去哪吃』变成了『中午订哪家的外卖』。古人没有空调，平常人家最常用的莫过于扇子了。如果很不幸你家停电了，那你只能借白居易的一首诗来消暑了:</p>
<blockquote>
<h4 id="消暑诗"><a href="#消暑诗" class="headerlink" title="消暑诗"></a>消暑诗</h4><p>何以消烦暑，端坐一院中。<br>眼前无长物，窗下有清风。<br>散热由心静，凉生为室空。<br>此时身自保，难更与人同。</p>
</blockquote>
<p><img src="http://oeckzejn4.bkt.clouddn.com/blog/170716/Jk9lCG13FK.png?imageslim" alt="白居易躺"></p>
<p>虽然夏天有蚊子和烈日炎炎，但是也有树荫和凉风，冰激凌和甜西瓜，有美女的碎花裙和追逐的轻罗小扇。当然，学生时代还有漫长快乐的暑假。那年夏天，可能也像现在的天气，我坐在学校图书馆的一角，矫情的感叹着那个夏季:</p>
<blockquote>
<p>衣服上的汗渍<br>晒蔫儿的叶子<br>扑面而来的热风<br>无力摇着头的风扇<br>气温挑战体温的极限<br>汗毛孔妥协流着汗<br>太阳的殷勤<br>我们的哀叹<br>就像<br>热情的单恋</p>
<p>树荫下的凉风<br>温柔了谁的梦<br> 少女的碎花裙<br>装点了哪家的风景<br>追逐的轻罗小扇<br>拂出外婆的思念<br>萤火虫的小官灯<br>一闪一闪<br>映出童年的鬓面</p>
<p>夏日里<br>苍白的试卷<br>沙沙吟唱的笔尖<br>解放前的最后一战<br>蹩脚的告别<br>毕业了的青春<br>不会再见的再见</p>
<p>这个夏天<br>会不会留恋<br>会不会怀念<br>热情的单相思<br>终会成为<br>无法回头的爱恋</p>
</blockquote>
<p>现在拥挤在人潮人海，时间流转的匆匆忙忙，生活在仓促中跌跌撞撞，心里都是麻麻木木，遇到这样的天气，连抱怨都直接了当:『真他妈的热』!</p>
<blockquote>
<p>星空和大地<br>汹涌和安息<br>激情澎湃和麻木的自己<br>成熟和跨不去的幼稚<br>连不成思绪<br>也讲不出故事<br>这是夏天<br>也是四季</p>
</blockquote>
<p>『完』</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经入伏了，天气闷热难耐。所谓入伏，其实就是进入了三伏天，也就是是出现在小暑与处暑之间，是一年中气温最高且又潮湿、闷热的日子。百度百科说，三伏天的『伏』就是指『伏邪』，即所谓的『六邪』（指“风、寒、暑、湿、燥、火”）中的暑邪。&lt;/p&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第四周 - coding 之后</title>
    <link href="http://chuanqiang.github.io/2017/07/10/after-coding/"/>
    <id>http://chuanqiang.github.io/2017/07/10/after-coding/</id>
    <published>2017-07-10T14:48:09.000Z</published>
    <updated>2017-07-16T15:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>图书项目wap端和后台终于上线了，看着自己写的代码，有条不紊的跑在服务器上，用抽象的逻辑，托起一个个色彩斑斓的页面。看 Log 在漆黑背景的 xshell 里一行行的输出，像是新生婴儿柔嫩却充满生命力的脉搏。</p>
<a id="more"></a>
<p><img src="http://oeckzejn4.bkt.clouddn.com/blog/170710/i6adCaGf2F.png?imageslim" alt="图书首页"><br>该项目的功能主要是一个图书商城，这次完成的是图书后台和移动浏览器端的实现，技术难点不多，但是杂，页面较多，关于购物车、物流、页面效果等实现上费心不少。</p>
<p>开发的最后这一周，可谓艰辛。我从没想到自己能有这么强的战斗力，连续熬夜，奋战到后半夜，除了coding，心无旁骛。每天想的都是如何解决bug，吃饭和睡觉都成了成了写代码的条件。在全身心投入的状态下，时间过得飞快。有一天，熬到后半夜四点，仍然劲头十足，脑袋正常流转。自己在朋友圈里嘚瑟了一下：</p>
<blockquote>
<p>其实来瓶红牛，我还能再战！  </p>
</blockquote>
<p>在这种节奏中，我竟找到了对生活久违的激情。在高压下的人往往能做出自己意想不到的事情，所以也懂得了一个道理，那就是:</p>
<blockquote>
<p>人就是天生懒惰得动物，所以必须逼一逼自己。  </p>
</blockquote>
<p>当然，之所以最后这么紧张，还是因为自己的原因导致的，好在终于如期发版了。虽然仍有遗憾，有bug和不完美，但既然『人无完人』，这些bug在不影响功能的前提下，之后再改掉便可。这期间多亏了儒冰哥的相助，要不是他，肯定又要延迟上线的。</p>
<p>这次从出需求，到页面设计，到代码实现，测试，上线。回顾整个过程，其实自己心里是不满意的。期间暴露出了许多的问题，包括技术上的以及心态上的。</p>
<p>首先，体现出的是技术上的不足，直接导致的是开发的效率低，代码反复纠错，不能一气呵成正确且漂亮的代码。虽然有初入公司，对原有框架和业务的不熟悉，但更多的是经验和积淀薄弱，遇到一些问题，不能最快最好的做找到解决的切面，不能像冰哥似的一看问题就能大致知道可能是哪出的错，而不是像无头苍蝇似的翻找代码。</p>
<p>第二，细节问题。虽然程序猿里绝大部分是英勇无畏的汉子，但coding代码确实是一个特别细致的活，需要你认真仔细。一个标点，一个符号错了都能导致程序崩溃。因此需要你把握每一个丁点儿的细节，杜绝似是而非，马马虎虎。另外还需要掌握技术的细节，比如jQuery函数你可能写的挺顺，可是忽略了冒泡的问题，也有可能知道要避免冒泡，但却因为采取的方法不同，在阻止冒泡事件的同时，也把默认事件给阻止了。总之，事无巨细，摆好心态。</p>
<p>第三，没有预估好工作量，过于懒惰和乐观。前松后紧的节奏，把事情堆压到了最后一两周，导致最后很被动，只能加班加点的搞了。在做计划的时候一定要把时间压缩80%，比如让你十天做的任务，一定要在前八天做完。因为计划赶不上变化，就出应对突发事件的余地。也就是所谓的『凡事预则立不预则废』。</p>
<p>接下来是pc前端的功能实现，吃一堑，长一智。一定要接受教训，不能重蹈覆辙，尽量做的迅速而完美。其实撸代码像是写作亦或书法，每个人有每个人的风格，除了代码的对错，也有美丑之分。美的代码体现在格式到里面的逻辑到封装性，从而体现在功能的容错性、稳定性、性能等等。</p>
<p>把 coding 这个看似枯燥的工作，当成一个思维的乐趣和充满意义和美感的事情，这是以后心态上自己要转变和追求的。</p>
<p>『完』</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图书项目wap端和后台终于上线了，看着自己写的代码，有条不紊的跑在服务器上，用抽象的逻辑，托起一个个色彩斑斓的页面。看 Log 在漆黑背景的 xshell 里一行行的输出，像是新生婴儿柔嫩却充满生命力的脉搏。&lt;/p&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>长安十二时辰-书摘</title>
    <link href="http://chuanqiang.github.io/2017/06/17/changan-twelve-hour/"/>
    <id>http://chuanqiang.github.io/2017/06/17/changan-twelve-hour/</id>
    <published>2017-06-16T16:00:00.000Z</published>
    <updated>2017-06-17T09:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oeckzejn4.bkt.clouddn.com/blog/170617/GiFe9h5ei7.jpg?imageslim" alt="长安十二时辰"></p>
<a id="more"></a>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><blockquote>
<p>马伯庸<br>作家。人民文学奖、朱自清散文奖得主，有“文字鬼才”之誉。<br>被评为沿袭“‘五四’以来历史文学创作的谱系”，“文字风格充满奇趣”。</p>
</blockquote>
<p>老者须发皆白，身着宽袖圆领紫袍，腰佩金鱼袋；少年人脸圆而小，青涩之气尚未褪尽，眉宇之间却隐隐已有了三道浅纹，显然是思虑过甚。他穿一袭窄袖绿袍，腰间挂着一枚银鱼袋，手里却拿着一把道家的拂尘。</p>
<p>李泌把外袍胸襟扯开，将双臂撑在沙盘旁边，身子前倾，继续俯瞰着长安城的沙盘。他的犀利眼神扫视着每一栋建筑，似乎想用目光将那头狼生生剜出来。</p>
<p>两人各自跨上一匹，张小敬问道：”去哪？” 徐宾答道：“哎哎，咱们回光德坊的靖安司。” 他看了一眼牙门前的日晷：“得尽快赶到，嗯，得赶快，得跑一刻半呢。” “一刻之内准到。” 张小敬用无名指扫了扫马耳，马匹的灵敏反应让他很满意。</p>
<p>阙勒是个突厥名词，近似于九幽血狱，而霍多则是化为尘土之意。整个词既是一句诅咒，也是一种传说中的凶兽。“阙勒霍多”这四字，即使不懂突厥语的，也能感受到其中滔天的杀意。</p>
<p>鬼蜮伎俩</p>
<p>贺知章见火候差不多到了，肃容一拜，满怀深情道：“今日长安有事，正需要尊者与我靖安司行个方便，一并躬燃纯火，荡涤宵小呐。” 一听到“躬燃纯火”四字，大萨宝眼眶几乎都湿润起来。祆教以火为尊，这四个字真真打中了心思。老人颤巍巍地站起身来，放开拐杖，双手拢作火焰形状横在胸前，向贺知章深施一礼。 “祆众，愿为贺监前驱！”</p>
<p>杜药师心中一阵凛然，知道自己已经触及到了另外一座长安城。这座长安城见不得光，里面充斥着血腥与贪欲，没有律法，也没有道义，混乱凶残如佛家的修罗之狱，能在这里生存的，都是大奸大恶之人。即便是官府，也不敢轻易深入这一重世界。</p>
<p>张小敬没理他，对那男子道：“我只能救你们其中一个人离开，你可以选择是谁，但记住，只能选一个。” 说完之后，张小敬倒退几步，冷眼看着。男子先是惊疑，然后是惊喜，嘴里反复喃喃，但每次看向瞳儿，便心生犹豫，不肯明确说出一个名字。张小敬忽然把身子凑过去，耳朵贴近他，然后点了点头。 “好。” 张小敬放下鞭子，手起刀落，斩断吊着男子的麻绳。 韩郎滚落在地，先是楞了一下，自己根本什么都没说啊。可话到嘴边，突然犹豫了起来。他试探着挪动几步，看那几个凶神都没动作，然后眼底流泻出狂喜——仿佛有人替他做了决定，就不必心存愧疚了。他看看左右，无人阻拦，用袖口掩面，急忙朝着出口慌张跑去。 等到他走远之后，张小敬再次走到瞳儿面前，她呆呆地看着地上断成两截的绳子，螓首低垂，似乎不相信是真的。 “你骗我，他根本什么都没说！” 瞳儿忽然抬起头，愤怒地喊道。 “一个男人，不要听他说了什么，要看他做了什么。若他本无离意，我又怎能左右他的双腿？” 张小敬的语气平淡，陈述一个简单的事实。</p>
<p>李泌的手指捏紧衣角，喃喃说了一句突兀的话：“自古华山，只有一条路。” 檀棋、杜药师听到这里，无不抚膺叹息。他们冒着风险潜入卫署，已做好了孤立无援的准备，原来李泌也一直在外头奔走，从未放弃。两边拼尽全力，才奇迹般地把张小敬捞了出来。</p>
<p>刑求这门艺术，和房事一样，精髓在于前戏。</p>
<p>登徒子、死囚犯、凶神阎罗、不肯让女人代死的君子、酷吏、干员、游侠……此前短短几个时辰，檀棋已经见识到了张小敬的许多面孔，可她对这个人仍旧难以把握。如今这杂乱的人潮，反倒如潺潺溪水一般，洗褪了张小敬身上那些浮夸油彩，露出本来的质地。 檀棋的脑海里，凝练出两个字：寂寞。张小敬的身影十分落寞。周围越是热闹，这落寞感就越强。他穿行于这人间最繁华最旺盛的地方，却仿佛与周遭分别置身于两幅画内，虽相距咫尺，却永不相融。 从某种意义上来说，他比公子距离这尘世更远。</p>
<p>在他的独眼之中，一百零八坊严整而庄严地排列在朱雀大街两侧，在太阳的照耀下熠熠生辉，气势恢宏。他曾经听外域的胡人说过，纵观整个世界，都没有比长安更伟大、更壮观的城市。昨晚的喧嚣，并未在这座城市的肌体上留下什么疤痕，它依然是那么高贵壮丽，就好像永远会这样持续下去似的。 一滴晶莹的泪水，从张小敬干涸已久的眼窝里流淌而出，这还是他来长安九年以来的第一次。</p>
<p>唐代的长安城对我来说，是一个梦幻之地。这是一个秩序井然、气势恢宏的伟大城市，三教九流、五湖四海的诸色人物云集其中，风流文采与赫赫武威纵横交错，生活繁华多彩，风气开放多元。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oeckzejn4.bkt.clouddn.com/blog/170617/GiFe9h5ei7.jpg?imageslim&quot; alt=&quot;长安十二时辰&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="http://chuanqiang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="马伯庸" scheme="http://chuanqiang.github.io/tags/%E9%A9%AC%E4%BC%AF%E5%BA%B8/"/>
    
      <category term="小说" scheme="http://chuanqiang.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>第三周 - 成长路上的三个问题</title>
    <link href="http://chuanqiang.github.io/2017/06/17/three-question/"/>
    <id>http://chuanqiang.github.io/2017/06/17/three-question/</id>
    <published>2017-06-16T16:00:00.000Z</published>
    <updated>2017-06-17T12:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>有三个问题，是一直在思考的:</p>
<blockquote>
<p>你想得到什么<br>你能得到什么<br>怎么得到你想要的</p>
</blockquote>
<a id="more"></a>
<p>关于这三个问题，可能一直会伴随着我们的职业生涯和人生轨迹，并且不同的时间问题的答案也可能不同。从某一个角度来看，我们穷其一生就是为了把『你想得到的』通过『怎么得到你想要的』变为『你能得到的』。</p>
<h3 id="你想得到什么。"><a href="#你想得到什么。" class="headerlink" title="你想得到什么。"></a>你想得到什么。</h3><p>从长远来说:</p>
<blockquote>
<ol>
<li>找到为之奋斗一生的事业</li>
<li>经济独立</li>
<li>生活幸福</li>
</ol>
</blockquote>
<p>从短期来说</p>
<blockquote>
<ol>
<li>能力之提高</li>
<li>财富之积累</li>
<li>工作之晋升</li>
</ol>
</blockquote>
<h3 id="当下你能得到什么"><a href="#当下你能得到什么" class="headerlink" title="当下你能得到什么"></a>当下你能得到什么</h3><blockquote>
<ol>
<li>稳定的薪水</li>
<li>历练的机会</li>
<li>成长的空间</li>
</ol>
</blockquote>
<h3 id="怎么得到你想要的"><a href="#怎么得到你想要的" class="headerlink" title="怎么得到你想要的"></a>怎么得到你想要的</h3><p>上面两个是起点和结点，这个问题是起点通往结点的道路。怎么走，走多久，决定走到哪和得到什么。所以这个问题是以后要展开的。</p>
<hr>
<p>更新历史</p>
<ul>
<li>2017-06-17:完成初稿</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有三个问题，是一直在思考的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你想得到什么&lt;br&gt;你能得到什么&lt;br&gt;怎么得到你想要的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="公司" scheme="http://chuanqiang.github.io/tags/%E5%85%AC%E5%8F%B8/"/>
    
  </entry>
  
  <entry>
    <title>在初创公司你能得到什么</title>
    <link href="http://chuanqiang.github.io/2017/06/17/start-up-company/"/>
    <id>http://chuanqiang.github.io/2017/06/17/start-up-company/</id>
    <published>2017-06-16T16:00:00.000Z</published>
    <updated>2017-06-17T12:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>进入一个初创的互联网公司意味着你选择了一条充满荆棘的路。工作强度高，因为一些制度的不完善导致额外的工作量;因为公司资金短缺，福利待遇也不尽人意.唯一欣慰的可能就是面试时谈好的工资能按时发，虽然还可能面临公司经营不善倒闭的风，不过进入这种初创公司也能有不一般的体验和成长。</p>
<a id="more"></a>
<p>首先，小公司没有那么多条条框框，能够做到扁平化管理。就比如我们公司，领导员工都坐一块，没有经理、组长、老板的官衔儿，都磊哥、冰哥的叫。公司搞技术的不管什么职位，都忙忙碌碌的写代码。一般来说，公司氛围很好，制度不那么严苛，不像大公司的压抑和那么浓烈的阶级味道。</p>
<p>其次，小公司工作流程还没行程精细化的分配，可能前段后台，数据库表的设计都要你自己来，可能部署、维护、优化都要你亲力亲为。这样的结果是你可以涉及到一个项目的方方面面，而不只是在在后台开发这一亩三分地上耕作，很助于面向全栈开发，虽然累一些，需要学的东西多一些，但对于你技术的积累是很有帮助的。</p>
<p>另外，在初创公司，你可以见证公司的成长。一方面，你可以见证公司技术的更新迭代。初创公司刚开始在技术选型和前期代码的实现上都是不完善的，开始用户量少，没有那么大的并发，加上资金有限和开发周期短，对于一些高并发，分布式可能顾及不到。之后随着用户量的增多，之前的一些技术框架和代码实现肯定要经历重构，这个时候对你来说，可以见证从旧到新的迭代过程，一些框架底层的原理和深层次的意义可以理解的更透彻。</p>
<p>另一方面，你不光能经历一个公司技术的更新迭代，还能见证一个创业公司的成长，看一个创业公司如何从无到有，从小到大。公司成长中的资源分配，人事变迁，制度完善等等，这些对于拥有创业想法的人来说，是十分宝贵的。它能提高你的『逆商』。所谓逆商就是处于一种绝境状态下的自我修复能力。也就是说，人的一生中要经历非常多的挫折和打击，你会发现，抗打击能力强的人，会越挫越勇。大公司里其实都是相对业务上比较成功的公司，其实很难真正让你面对失败，而人只有多吃亏，才能更快成长和进步，这个大公司不会给你，只有创业公司才可以给你。初创公司的成长是一个不断试错的过程，而在这个过程中你能得到历练，并且失败了也是公司承担，对于你个人来说没有什么损失。</p>
<p>最后，在小公司你能获得更快的晋升机会，锻炼管理能力。小公司的人员流动尤其是人才流入是很快的，并且由于受资金限制，也不会招很多大牛。这样当你成长够快的时候，你就能脱颖而出，快速展露头脚。而如果是在一个成熟的大公司，这样的机会是很少的，即所谓的『乱世枭雄』。</p>
<p>综上，要珍惜当下的机遇，快速成长，这才是王道。</p>
<hr>
<p>更新历史</p>
<ul>
<li>2017-06-17:完成初稿</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入一个初创的互联网公司意味着你选择了一条充满荆棘的路。工作强度高，因为一些制度的不完善导致额外的工作量;因为公司资金短缺，福利待遇也不尽人意.唯一欣慰的可能就是面试时谈好的工资能按时发，虽然还可能面临公司经营不善倒闭的风，不过进入这种初创公司也能有不一般的体验和成长。&lt;/p&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="初创公司" scheme="http://chuanqiang.github.io/tags/%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/"/>
    
  </entry>
  
  <entry>
    <title>中国人对科学的三点误读</title>
    <link href="http://chuanqiang.github.io/2017/06/11/misread-science/"/>
    <id>http://chuanqiang.github.io/2017/06/11/misread-science/</id>
    <published>2017-06-10T16:00:00.000Z</published>
    <updated>2017-06-11T09:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>近代以来啊，中国人对西方科学的接触是越来越多。但是，有个问题不知你想过没有，即便是到了现在，我们是不是真正理解了科学的内在本质呢？北京大学哲学系教授吴国盛老师写过一篇文章，就指出我们对于科学的3点误读，并分析这些误读是怎么产生的，以及科学的本质应该是什么样的，我们一起来看看。</p>
<a id="more"></a>
<p>首先，中国人对科学的误读有哪三方面呢？<br>第一方面是，错把科学和技术对等起来，看作是一回事。近代中国人接受科学，是因为西方列强坚船利炮的轰击，我们技不如人，需要学习。而在中国人心中，这种“技”就是西方的赛先生——科学；第二方面是，中国人认为科学有着很强的实用主义色彩，也就是说，认为只有可以被利用的才是科学，在生活生产方面没有作用的就不算科学；第三方面是，把科学误读为分科之学，认为科学是有分不同学科的，忽略了它衍生出来的知识论传统。</p>
<p>那么，对科学的这些误读是怎么产生的呢？吴国盛教授说，科学不是中华民族土生土长的东西，是从外面引进来的，以本土的文化去对待外来的事物时就很容易引起误读。在西方，科学是一种有确定性的知识，是一种探究事物内在本质的精神。而在中国，往往就会简单地将科学看成是一种智力行为，觉得有了智商就可以搞科学，但实际上中国人的智商绝不能说低，但古代中国却没有发展出科学来。其实科学最本质的东西不在于智商，而在于文化。中国人对科学产生误读就是由于中西方文化的不同，中国人没有领悟到西方对于科学这种确定性的追求的内涵。</p>
<p>那确定性是什么呢？简单来说，就是追求要把事物的本质明白无误地说出来。举个例子，三角形内角和是180度，中国人只要测量一下得出结论就可以了。如果测量一个不行，就多测量几个。但是西方人会问，为什么一定是180度呢？有什么保证这个规律对所有三角形都是对的呢？于是就产生了演绎，产生了证明科学——如果一个定理在一套体系中得到证明，那它的正确性在这套体系中永远无法被质疑和否定，这就是一种确定性。</p>
<p>那么，西方文化为什么会对确定性有追求呢？这要从古代西方文化说起。在古希腊，人们认为最重要的是认识自己。什么是自己呢？通常人们通过在社会中的某些角色来定义，比如说你是你爸爸的儿子，是你妻子的丈夫等等，但这是真正的你自己吗？不同时间、地点、不同人眼中，你的角色都不一样。比如说今天你是老师，第二天被开除了，那你就不是老师了。</p>
<p>所以说，通过别人对你的定位来认识自己是不可靠的。<strong>希腊人认为需要找到你自身不变的东西，这才是真正的你自己。从巴门尼德开始，就坚持认为“存在者存在，不存在者不存在”，也就是说无论世间万物怎么变化，背后一定有一种不变的本质，这就是一种确定性，科学知识的存在必须依赖于这种确定性。</strong></p>
<p>后来柏拉图继承了这种思想，认为科学就是去发现规律，找到这种确定性的东西，这成为了西方思想的主流观念。而中国文化并不重视对变化背后这种确定性的追求，比如说儒家和道家，认为变化是绝对的，追求的是如何在变化中达到中庸，找到最恰当的应对方法，而没有把问题的本质弄清楚。</p>
<p>最后，中西方文化之间的这种差异是怎么产生的呢？<strong>首先，人一生下来就在某种特定的环境中，这种特定的环境会形成某种文化。例如说中国，在农耕经济条件下，人口流动性非常低，人与人之间的关系是基于血缘，这时候亲情就成了核心要素。而希腊由于地理环境特殊，人们需要经常迁移，这种人口的流动使得社会关系不能靠血缘来维系，那么要怎么形成一个有秩序的社会呢？这就需要建立一种契约文化，比如说圣经，说的是上帝与人订约，其实就是民间很早就存在的契约行为。</strong></p>
<p>西方这种契约精神使得他们在面对紧急事件、需要作出决策时，就会组织投票，这就必须要求每个人都是一个独立的个体，这些个体最根本的特点就是自由。这种对自由的追求才会让人们思考什么是自己这个问题，才会考虑追求事物的内在本质是什么。而中国则不一样，遇到紧急事件时希望出现德高望重的人来引导大家，而不是去看每个人的想法是什么，这也就束缚了中国人对于自由、对于事物本质的追求。</p>
<p>你看，<strong>中国人误读科学，不单单有历史原因，更重要的是我们缺乏对自由的认同，没有思考过什么是自己，更没有从中领悟到确定性对于科学是多么重要，所以没有掌握科学之所以为科学的精髓所在。</strong>在21世纪的今天，中国已经完全被卷入了现代化的浪潮，采用了西方的生产和生活方式，但更重要的是，我们应该理解这种模式背后的逻辑，学习平等、自由的理念，和领略这种追求确定性知识的精神，再结合中国自身的特色，才能真正走出一条中国式的发展道路。</p>
<hr>
<p>本文源自：微信公众号“中国健康与养老追踪调查”（吴国盛：中国人对科学的误读）音频稿：陈成康讲述：于浩</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近代以来啊，中国人对西方科学的接触是越来越多。但是，有个问题不知你想过没有，即便是到了现在，我们是不是真正理解了科学的内在本质呢？北京大学哲学系教授吴国盛老师写过一篇文章，就指出我们对于科学的3点误读，并分析这些误读是怎么产生的，以及科学的本质应该是什么样的，我们一起来看看。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="http://chuanqiang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="科学" scheme="http://chuanqiang.github.io/tags/%E7%A7%91%E5%AD%A6/"/>
    
      <category term="读书" scheme="http://chuanqiang.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>第二周 - 长胖</title>
    <link href="http://chuanqiang.github.io/2017/06/11/fat/"/>
    <id>http://chuanqiang.github.io/2017/06/11/fat/</id>
    <published>2017-06-10T16:00:00.000Z</published>
    <updated>2017-06-11T13:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>从来没有想过我会到要减肥的程度，但是现在看着镜子里的自己，尤其是微微隆起的肚子，冲着镜子抛去了一个嫌弃的眼神。</p>
<a id="more"></a>
<p>岁月是一把杀猪刀啊，我需要的是成长不是长胖啊，看看相册里以前的自己和镜子里那个陌生的身影，我掩面而泣。<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170611/8Il5mfIkff.JPG" alt="小时候的我"><br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170611/8KFB6f95DE.JPG" alt="大学时候的我"><br><img src="http://oeckzejn4.bkt.clouddn.com/blog/170611/JiiKKajcGA.JPG" alt="现在的我"></p>
<p>以上分别是小时候的我，刚上大学的我，现在的我。注意看最后一张我是收着肚子的。体重也从一百三不到直逼一百五。因为我们家人没有很胖的体型，并且从小到大我也一直偏瘦，学生时代怎么吃都长不胖，所以我一直坚信自己是天生丽质，含有瘦的基因，怎么都吃不胖的。</p>
<p>事实证明我是太过乐观了。久坐不动，暴饮暴食，终于打破了“先天的优势”。虽然一眼看上去『不胖啊』，但自己肚子上的肉自己知道。</p>
<p>每个瘦人有不同的瘦发，但胖子却有同样的胖法。就两个原因：1. 懒  2. 馋 </p>
<p>馋嘴导致吃的多，增加脂肪。懒导致不运动，脂肪积累。那解决方法也很简单喽，控制饮食，多多运动。但哪有上嘴唇碰下嘴唇这么容易，不然街头早没胖子了。所以，看到印度国宝级演员阿米尔汗拍摄『摔跤吧，爸爸』由瘦子吃撑胖子再减会成瘦子的过程，实在是无比佩服。</p>
<p>行动是达成目标的前提，并且是持续不断的行动。</p>
<p>最近也意识到长胖问题的严重性——我可不想再过几年成了大腹便便的大叔，并且还带来一系列的健康问题。</p>
<p>村上春树说：</p>
<blockquote>
<p>连跑步都坚持不下来的人，还怎么创作  </p>
</blockquote>
<p>同样，体重都控制不住的人，怎么去掌控自己的人生。</p>
<p>现在虽然工作忙，但也暗暗下决心要保证每周至少三次跑步，从家都地铁站上下班骑自行车，尽量在地铁上站着，在公司多走动。</p>
<p>我一直认为，学习，运动，读书，交际，游戏，美食，影视，都是生活中不可缺少的元素，而现在我的肚子正在大声的训斥我：你丫的该运动了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从来没有想过我会到要减肥的程度，但是现在看着镜子里的自己，尤其是微微隆起的肚子，冲着镜子抛去了一个嫌弃的眼神。&lt;/p&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="长胖" scheme="http://chuanqiang.github.io/tags/%E9%95%BF%E8%83%96/"/>
    
  </entry>
  
  <entry>
    <title>第一周-一个开始</title>
    <link href="http://chuanqiang.github.io/2017/06/03/one-start/"/>
    <id>http://chuanqiang.github.io/2017/06/03/one-start/</id>
    <published>2017-06-02T16:00:00.000Z</published>
    <updated>2017-06-11T09:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个开始，开始写周记。学生时代也写过周记，多为应付老师的家庭作业，之后也就淡忘了。2017年已经过了一半，学校生涯已经完结，人生已经走完了二十多载，但现在仍是一个开始。有些道理可能领悟过，之后又混沌了，有些事情当下明白着，以后可能还会忘却。但有一个开始总是好的，毕竟任何事情的完结都是从一个开始开始的。</p>
<hr>
<a id="more"></a>
<p>人都会有身处混沌却安然不知的情景，然后忽然有一个外界力量给你当头棒喝，让你醍醐灌顶。有时候是一部励志电影，有时候是和别人交流时的顿悟，有时候是一本书。我就是因为一本书——『奇特的一生』。因为现在的公司上班距离变远了，通勤的时间增长，随着对公司环境和新工作的适应，也开始找到自己的节奏，也开始在地铁上看些书。刚刚看完柳比歇夫『奇特的一生』，喝了好大一碗鸡血。愣愣的看地铁穿梭在黑漆漆的隧道，时光在耳边呼啸而过。不禁想到了朱自清的『匆匆』，时间都溜走了，从脸盆里，从指尖上，从我的酣睡和游戏中。更加觉得自己对生命和时间的忽视有多么严重。我需要好好思考一下自己，整理一下心中的念头，想清楚一些问题，关于自己，关于生活，关于目标和当下的关系。总之，脑海中许多混混沌沌的思绪，都应该被整理了。这也是这本书给我的第一个收获。</p>
<p>脑海中开始回想，之前的岁月哪去了，竟然不留一点痕迹，但脑海中的记忆像是海滩上的字，被海浪冲刷的越来越淡。。。记忆显然不是留存记忆的好办法，那该用什么呢？影像和文字。影像自然不必多说，文字除了记录日常以外，更明显的优势是记录情感和想法。这是影像远远不可比拟的。至于弱点，那就是时间成本以及要克服人的惰性。但这样的付出是值得的，因为在记录的时候，思考自己的这一天，总结归纳，往往会有意想不到的收获。因此，我开始再一次拿起日记，记录下每天的事情。有意义的甚至无意义的，因为现在的你不知道当前经历的事对于以后的自己所代表的意义和珍贵。日记在下班的地铁上用iPhone上的Bear写，周记在周末用电脑上的MarkEditor敲，这种『有意义』的事情自己竟然都现在才后知后觉，对自己无语三分钟。。。做事情最晚的是明天，最佳时间是现在。so，do it now.</p>
<p>最近还看了埃隆马斯克的传记『硅谷钢铁侠』，瞻仰了一下牛逼人的风采。另外也看出这些年来实体经济的创新不足，人们的目标已经从冒险创造全新的行业和伟大想法，变成了通过取悦消费者，以及批量生产简单应用和广告来赚快钱。我们这一代人中最优秀的头脑，都在思考如何让人们点广告。作者认为，认为现在有非常多的聪明人都在致力于互联网、金融和法律，这是我们没能看到更多创新的部分原因。这也引导我思考互联网的出现究竟能给人们带来了什么，最近AlphaGo连胜对战中国围棋九段高手世界排名第一的柯杰三局，也引发了一场AI讨论的热潮。AI、VR时代来临，究竟对于我们的生活意味着什么，由此开始看廖雪峰写的『未来世界的幸存者』，希望找到一些答案。</p>
<p>另外，步入编程行业后，我发现自己的表达能力大不如前，表达问题找不到准确的简练的语录。主要原因是每天都是一个人默默的敲代码，交流不多，脑子可能好使了，但嘴巴变笨了。但表达能力确实是十分重要的，许多事情的成败就是说与不会说的区别，在销售行业犹如是。一件事情有的人十分钟能说的清楚明白，有的人一个小时也啰嗦不完，这就是差距。首先要做到表达准确清楚；其次是简洁明了，中心突出；然后能做到调理清晰，逻辑感强；最后是引人入胜，带动情绪。以后自己要多加锻炼，有意识的练习提高。没事多招人唠唠，除了锻炼表达，还能增强情感，收获知识。</p>
<p>第一周，是周记的开始，之后最重要的便是坚持。To persevere means victory.</p>
<p>2017-06-03 16:55:10</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个开始，开始写周记。学生时代也写过周记，多为应付老师的家庭作业，之后也就淡忘了。2017年已经过了一半，学校生涯已经完结，人生已经走完了二十多载，但现在仍是一个开始。有些道理可能领悟过，之后又混沌了，有些事情当下明白着，以后可能还会忘却。但有一个开始总是好的，毕竟任何事情的完结都是从一个开始开始的。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="周记" scheme="http://chuanqiang.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>成长路上的独白(一)</title>
    <link href="http://chuanqiang.github.io/2017/05/13/say-myself-one/"/>
    <id>http://chuanqiang.github.io/2017/05/13/say-myself-one/</id>
    <published>2017-05-13T14:40:45.000Z</published>
    <updated>2017-05-13T14:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于换掉了工作，就像是终于摆脱了一个略显失败的自己。</p>
<a id="more"></a>
<p>一年以来的工作旅途，并没有达到自己的期望，没那么跌宕，没那么辛苦，没那么多成长，甚至可以用平凡和无聊这样的词汇来形容。</p>
<p>收获的不尽人意，反而丢弃了许多东西。读书写作，尝尝被生活的琐碎耽搁;远方的梦想也常常在仓促的时间前止步。有时候回想，对于我来说，到底什么才是重要的，什么才能让自己提升所谓的幸福感。</p>
<p>步履匆匆间，是什么和什么做了交换，这样的交换到底能不能承受住时间的检验。</p>
<p>坐在夜晚嘈杂的地铁上，看着一张张陌生而疲惫的面孔，想象不出他们匆匆于何处，他们的欢笑是否多于愁苦，他们喜不喜欢这样的生活。</p>
<p>新的工作是在一个小互联网公司，节奏快，充满了挑战，有许多自己未知的事物需要学习和消化，时间成了最渴求的东西。因为没有大公司那么多条条框框，许多东西需要自己设计和思考如何实现，渐渐有了coding代码时的畅快感，把一个个实实在在的需求通过指尖在键盘上的飞驰变成屏幕上一个个可以供用户使用的功能模块，这其中还是很有意思的。</p>
<blockquote>
<p>大冰说：有些时候，有意思比有意义更有意义。</p>
</blockquote>
<p>无聊是生活的敌人，它会泯灭时间的珍贵，让你感觉不到生活的乐趣，只想时间快一点，再快一点，好拜托现在的生活。</p>
<p>虽然现在仍旧走在自己规划的成长道路上：第一年到多少薪资，找什么样的工作。但规划路线和心跳的轨迹却有了距离。希望自己能用自己的努力来弥合这中间的裂缝，让自己再坚韧一些，来承受这些成长中的剧痛。既然选择了改变，既然祈求成长，就应该做好风雨兼程的准备。</p>
<p>朋友圈看到一个小文，希望在自己的时区里能越来越快，虽然上帝准时，但你首先要保证不迟到。</p>
<blockquote>
<p>命运总会给你最好的安排：</p>
<p>纽约时间比加州时间早三个小时，<br>New York is 3 hours ahead of California,</p>
<p>但加州时间并没有变慢。<br>but it does not make California slow.</p>
<p>有人22岁就毕业了，<br>Someone graduated at the age of 22,</p>
<p>但等了五年才找到好的工作！<br>but waited 5 years before securing a good job!</p>
<p>有人25岁就当上CEO，<br>Someone became a CEO at 25,</p>
<p>却在50岁去世。<br>and died at 50.</p>
<p>也有人迟到50岁才当上CEO，<br>While another became a CEO at 50,</p>
<p>然后活到90岁。<br>and lived to 90 years.</p>
<p>有人依然单身，<br>Someone is still single,</p>
<p>同时也有人已婚。<br>while someone else got married.</p>
<p>奥巴马55岁就退休，<br>Obama retires at 55,</p>
<p>川普70岁才开始当总统。<br>but Trump starts at 70.</p>
<p>世上每个人本来就有自己的发展时区。<br>Absolutely everyone in this world works based on their Time Zone.</p>
<p>身边有些人看似走在你前面，<br>People around you might seem to go ahead of you,</p>
<p>也有人看似走在你后面。<br>some might seem to be behind you.</p>
<p>但其实每个人在自己的时区有自己的步程。<br>But everyone is running their own RACE, in their own TIME.</p>
<p>不用嫉妒或嘲笑他们。<br>Don’t envy them or mock them.</p>
<p>他们都在自己的时区里，你也是！<br>They are in their TIME ZONE, and you are in yours!</p>
<p>生命就是等待正确的行动时机。<br>Life is about waiting for the right moment to act.</p>
<p>所以，放轻松。<br>So, RELAX.</p>
<p>你没有落后。<br>You’re not LATE.</p>
<p>你没有领先。<br>You’re not EARLY.</p>
<p>在命运为你安排的属于自己的时区里，一切都准时。<br>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于换掉了工作，就像是终于摆脱了一个略显失败的自己。&lt;/p&gt;
    
    </summary>
    
      <category term="独白" scheme="http://chuanqiang.github.io/categories/%E7%8B%AC%E7%99%BD/"/>
    
    
      <category term="独白" scheme="http://chuanqiang.github.io/tags/%E7%8B%AC%E7%99%BD/"/>
    
      <category term="成长" scheme="http://chuanqiang.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>深入 Web 请求过程</title>
    <link href="http://chuanqiang.github.io/2017/02/25/web-request/"/>
    <id>http://chuanqiang.github.io/2017/02/25/web-request/</id>
    <published>2017-02-25T09:57:12.000Z</published>
    <updated>2017-02-25T10:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>深入 Web 请求过程。</p>
<a id="more"></a>
<h4 id="B-S-架构的好处"><a href="#B-S-架构的好处" class="headerlink" title="B/S 架构的好处"></a>B/S 架构的好处</h4><ul>
<li>客户端使用同一的浏览器。浏览器具有统一性，不需要特殊的配置和网络连接，屏蔽了服务的差异性。</li>
<li>浏览器的交互特性使用户使用简便，继承性强。</li>
<li>服务端基于统一的 HTTP 协议，采用相对规范的开发模式，节省了开发成本。<ul>
<li>基于 HTTP 协议的服务器很多: Apache、Nginx、Tomcat、JBoss。可以直接拿来用。</li>
</ul>
</li>
</ul>
<h2 id="B-S-网络架构"><a href="#B-S-网络架构" class="headerlink" title="B/S 网络架构"></a>B/S 网络架构</h2><p>大多数传统的互联网应用程序采用长连接的交互模式，而 <strong>HTTP 协议采用无状态的短连接的通信方式</strong>。一次请求就完成了一次数据交互，通常也对应一个业务逻辑。网络架构如下:<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/20170219-174503352.jpg" alt=""></p>
<h3 id="请求一个网址的步骤"><a href="#请求一个网址的步骤" class="headerlink" title="请求一个网址的步骤"></a>请求一个网址的步骤</h3><ul>
<li>在浏览器中输入一个 URL。</li>
<li>浏览器请求 DNS 把域名解析成对应的 IP 地址</li>
<li>根据 IP 地址在在互联网上找到对应的服务器，并向服务器发送一个 get 请求。<ul>
<li>需要负载均衡设备来平均分配所有用户的请求</li>
<li>请求的数据可能存储在分布式缓存或者静态文件或者数据库中。</li>
</ul>
</li>
<li>由这个服务器决定返回默认的数据资源给访问的用户<ul>
<li>浏览器解析返回的静态资源数据时，又会发起另外的 HTTP 请求，请求可能发生在 CDN 上</li>
</ul>
</li>
</ul>
<h4 id="需要遵守的原则"><a href="#需要遵守的原则" class="headerlink" title="需要遵守的原则"></a>需要遵守的原则</h4><ul>
<li>互联网上所有的资源都用一个 URL(统一资源定位符) 来表示。</li>
<li>必须基于 HTTP 协议与服务端交互</li>
<li>数据展示必须在浏览器中进行(只有在浏览器上才能恢复得到的数据资源的容貌)</li>
</ul>
<h3 id="HTTP-解析"><a href="#HTTP-解析" class="headerlink" title="HTTP 解析"></a>HTTP 解析</h3><p>发起一个 HTTP 请求就是建立一个 Socket 通信的过程。</p>
<p><strong>Http Header</strong>: 控制互联网用户数据的传输，以及浏览器的渲染行为和服务器的执行逻辑。</p>
<p><strong>1. 常见的 HTTP 请求头</strong></p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>用于指定客户端接受的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>用于指定可接受的内容编码，如<code>Accept-Encoding:gzip.deflate</code></td>
</tr>
<tr>
<td>Accept-Language</td>
<td>用于指定一种自然语言。如<code>Accept-Language:zh-cn</code></td>
</tr>
<tr>
<td>Host</td>
<td>用于指定被请求资源的 Internet 主机和端口号，如<code>Host:www.taobao.com</code></td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端将它的操作系统、浏览器和其他属性告诉服务器</td>
</tr>
<tr>
<td>Connection</td>
<td>当前连接是否保持，如<code>Connection:Keep-Alive</code></td>
</tr>
</tbody>
</table>
<p><strong>2. 常见的 HTTP 相应头</strong></p>
<table>
<thead>
<tr>
<th>相应头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Server</td>
<td>使用服务器名称，如 Server: Apache/1.3.6(Unix)</td>
</tr>
<tr>
<td>Content-Type</td>
<td>用来指明发送给接收者的实体正文的媒体类型，如 Content-Type/html;charset=GBK</td>
</tr>
<tr>
<td>Content-Language</td>
<td>描述了资源所用的自然语言，与 Accept-Language 对应</td>
</tr>
<tr>
<td>Content-Length</td>
<td>指明实体正文的长度，用以字节方式存储的十进制数字来表示</td>
</tr>
<tr>
<td>Keep-Alive</td>
<td>保持连接的时间，如 Keep-Alive:timeout=5，max=120</td>
</tr>
</tbody>
</table>
<p><strong>3. 常见的HTTP状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td>302</td>
<td>临时跳转，跳转的地址通过 Location 指定</td>
</tr>
<tr>
<td>400</td>
<td>客户端请求有语法错误，不能被服务器识别</td>
</tr>
<tr>
<td>403</td>
<td>服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td>404</td>
<td>请求的资源不存在</td>
</tr>
<tr>
<td>500</td>
<td>服务器发生不可预期的错误</td>
</tr>
</tbody>
</table>
<h4 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h4><p><strong>Ctrl + F5</strong>:浏览器会直接向目标 URl 发送请求，而不会使用缓存的数据；HTTP 的请求头中会增加一些请求头，告诉服务器我们获取最新的数据而不是缓存。</p>
<p><strong>1. Cache-Control/Pragma</strong></p>
<p>这个 HTTP Head 字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。</p>
<p><strong>字段的可选值</strong></p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Public</td>
<td>所有内容将都被缓存，在响应头中设置</td>
</tr>
<tr>
<td>Private</td>
<td>内容值缓存到私有缓存中，在响应头中设置</td>
</tr>
<tr>
<td>no-cache</td>
<td>所有内容都不会被缓存，在请求头和响应头中设置</td>
</tr>
<tr>
<td>no-store</td>
<td>所有内容都不会被缓存到或缓存成 Internet 临时文件中，在相应头中设置</td>
</tr>
<tr>
<td>must-revalidation/proxy-revalidation</td>
<td>如果缓存的内容失效，请求必须发送到服务器/代理进行重新验证，在请求头中设置</td>
</tr>
<tr>
<td>max-age=xxx</td>
<td>缓存的内容将在 xxx 秒后失效，只在 HTTP 1.1中可用</td>
</tr>
</tbody>
</table>
<p><strong>2. Expires</strong></p>
<p>Expires 通常的格式为 Expires:Sun, 19 Feb 2017 12:53:33 GMT，后面跟一个日期和时间，超过这个时间值后，缓存的内容将失效。</p>
<p><strong>3. Last-Modified/Etag</strong></p>
<p>用于表示一个服务器上的资源的最后修改时间，资源可以是静态(静态内容自动加上 Last-Modified 字段) 或动态的内容(如 Servlet 提供了一个 getLastModified 方法用于检查某个动态内容是否已经更新)，通过这个最后修改时间可以判断当前请求的资源是否是最新的。</p>
<h3 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h3><h4 id="DNS-域名解析的过程"><a href="#DNS-域名解析的过程" class="headerlink" title="DNS 域名解析的过程"></a>DNS 域名解析的过程</h4><p>当用户在浏览器中输入域名并按下回车键后:</p>
<ol>
<li>浏览器检查缓存中有没有这个域名对应的 IP 地址。如果有，解析结束(域名的缓存时间通过 TTL 属性设置)。</li>
<li>如果用户的缓存中没有，浏览器检查操作系统缓存中是否有这个域名对应的 DNS 解析结果(Windows 中通过<code>C:\Windows\System32\drivers\etc\hosts</code>文件设置)。</li>
<li>以上两个过程无法解析时，操作系统会把这个域名发送给 LDNS，也就是本地的域名服务器(提供DNS解析服务)，如果是在学校接入互联网，那么你的DNS服务器肯定在学校，如果是小区，这个DNS 时提供给你接入互联网的提供商，即电信、联通，也就是 SPA。这个 DNS 可以通过 <code>ipconfig</code> 查询这个地址。</li>
<li>如果 LNDS 仍没有命中，就直接到 Root Server 域名服务器请求解析。</li>
<li>根域名服务器返回给本地域名服务器一个所查询域的主域名服务器(gTLD)地址。gTLD是国际顶级域名服务器，如<code>.com、.cn、.org</code>等，全球只有13台左右。</li>
<li>本地域名服务器(Local DNS Server)再向上一步返回的 gTLD 服务器发送请求。</li>
<li>接受请求的gTLD服务器查找并返回此域名对应的 Name Server 域名服务器的地址，这个 Name Server 通常就是你注册的域名服务器。</li>
<li>Name Server 域名服务器会查询存储的域名和 IP 的映射关系表，正常情况下根据域名得到目标的IP记录，连同一个 TTl 值返回给 DNS Server 域名服务器。</li>
<li>返回该域名对应的 IP 和TTl 值，Local DNS Server 会缓存这个域名和 IP 的对应关系。</li>
<li>把解析的结果返回给用户。</li>
</ol>
<p><code>nslookup</code>命令查询域名解析的结果。</p>
<h4 id="清除缓存的域名"><a href="#清除缓存的域名" class="headerlink" title="清除缓存的域名"></a>清除缓存的域名</h4><p>DNS 域名解析后会缓存解析结果，主要在两个地方缓存: 1. Local DNS Server；2. 用户本地机器。</p>
<p><strong>本机缓存的清除</strong>: 1. 在命令模式下执行<code>ipconfig/flushdns</code> 来刷新缓存；2. 重启</p>
<h4 id="域名解析的方式"><a href="#域名解析的方式" class="headerlink" title="域名解析的方式"></a>域名解析的方式</h4><p>域名解析记录只要分为A记录、MX记录、CNAME记录，NS记录、TXT记录</p>
<ul>
<li>A（Address）记录：用来指定域名对应的IP地址，可以将多个域名地址解析到一个IP地址，但是不能讲一个域名解析到多个IP地址</li>
<li>MX（Mail Exchange）记录：讲某个域名下的邮件服务器指向自己的Mail Server</li>
<li>CNAME（Canonical Name）记录：别名解析就是可以为一个域名设置一个或多个别名</li>
<li>NS记录：为某个域名指定DNS解析服务器</li>
<li>TXT记录：为某个主机名或域名设置说明</li>
</ul>
<h3 id="CDN-工作机制"><a href="#CDN-工作机制" class="headerlink" title="CDN 工作机制"></a>CDN 工作机制</h3><p>CND(Content Delivery Network)，内容分布网络，是构筑在现有Internet 上的一种先进的流量分布网络。目的是通过现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户就近取得所有内容，提高用户访问速度。</p>
<p><img src="http://oeckzejn4.bkt.clouddn.com/blog/20170220-211544648.png" alt="image"></p>
<p>CDN=镜像（Mirror）+缓存（Cache）+整体负载均衡（GSLB）</p>
<p>CDN 以缓存网站中的静态数据为主，如css、js、图片和静态页面等数据，用户从主站服务器请求到动态内容后再从 CDN 上下载这些静态数据，从而加速网页数据的下载内容。</p>
<p><strong>CDN请求与处理流程</strong>：向Local DNS 服务器发送请求，一般经过迭代解析后回到这个域名的注册服务器解析（每个公司都会有一台DNS解析服务器），这个服务器会把请求重新CNAME解析到另一个域名，这个域名最终会指向CDN全局中的DNS负载均衡服务器，再由这个GTM来最终分配是哪个地方的访问用户吗，返回给离这个用户最近的CDN节点。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡就是对工作任务进行平衡，分摊到多个操作单元上执行。如图片服务器、应用服务器，共同完成工作任务。提高服务器响应速度及利用效率。</p>
<p><strong>三种负载均衡架构</strong>分别是链路负载均衡、集群负载均衡、操作系统负载均衡</p>
<p>链路负载均衡：通过DNS解析到不同的IP，然后用户根据这个IP来访问不同的目标服务器</p>
<p>集群负载均衡：</p>
<ul>
<li>硬件负载均衡：性能好，价格高</li>
<li>软件负载均衡：成本低，多次代理，网络延时</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入 Web 请求过程。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://chuanqiang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Web请求" scheme="http://chuanqiang.github.io/tags/Web%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>SLF4J使用和与Log4J对比</title>
    <link href="http://chuanqiang.github.io/2017/02/25/SLF4J/"/>
    <id>http://chuanqiang.github.io/2017/02/25/SLF4J/</id>
    <published>2017-02-25T09:47:57.000Z</published>
    <updated>2017-02-25T09:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>每一个Java程序员都知道日志对于任何一个Java应用程序，尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库如<code>java.util.logging、Apache log4j、logback</code>。</p>
<p>在这篇文章中，我们将学习为什么使用<code>SLF4J</code>比<code>log4j</code>或者<code>java.util.logging</code>要优秀。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>SLF4J不同于其他日志类库，与其它有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个<strong>抽象层</strong>（ abstraction layer），它<strong>允许你在后台使用任意一个日志类库</strong>。</p>
<p>当你编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。</p>
<p>如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了<code>SLF4J</code>，你可以继续使用你的日志类库而加载和维护一个新的日志框架。</p>
<p>总的来说，<strong>SLF4J使你的代码独立于任意一个特定的日志API</strong>，这是一个对于开发API的开发者很好的思想。虽然抽象日志类库的思想已经不是新鲜的事物而且Apache commons logging也已经在使用这种思想了，但现在SLF4J正迅速成为Java世界的日志标准。让我们再看看几个使用SLF4J而不是log4j、logback或者java.util.logging的理由。</p>
<h3 id="SLF4J对比Log4J，logback和java-util-Logging的优势"><a href="#SLF4J对比Log4J，logback和java-util-Logging的优势" class="headerlink" title="SLF4J对比Log4J，logback和java.util.Logging的优势"></a>SLF4J对比Log4J，logback和java.util.Logging的优势</h3><ol>
<li>使用SLF4J写日志语句的主要出发点是使得你的程序独立于任意特定的日志类库，依赖于特定类可能需要不同与你已有的配置，并且导致更多维护的麻烦。</li>
<li>占位符(place holder)的使用。</li>
</ol>
<p>在代码中表示为<code>{}</code>的特性。占位符是一个非常类似于在String的<code>format()</code>方法中的<code>%s</code>，它会在运行时被某个提供的实际字符串所替换。</p>
<p>这不仅降低了你代码中字符串连接次数，而且还节省了新建的String对象。因为String对象是不可修改的并且它们建立在一个String池中，它们消耗堆内存( heap memory)而且大多数时间他们是不被需要的，例如当你的应用程序在生产环境以ERROR级别运行时候，一个String使用在DEBUG语句就是不被需要的。</p>
<p>通过使用SLF4J,你可以在<strong>运行时延迟字符串的建立</strong>，这意味着<strong>只有需要的String对象才被建立</strong>。而如果你已经使用log4j，那么你已经对于在if条件中使用debug语句这种变通方案十分熟悉了，但SLF4J的占位符就比这个好用得多。</p>
<h4 id="使用对比"><a href="#使用对比" class="headerlink" title="使用对比"></a>使用对比</h4><p>Log4j:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">    logger.debug(<span class="string">"Processing trade with id: "</span> + id + <span class="string">" symbol: "</span> + symbol);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SLF4J：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logger.debug(<span class="string">"Processing trade with id: &#123;&#125; and symbol : &#123;&#125; "</span>, id, symbol);</div></pre></td></tr></table></figure>
<p>在SLF4J，我们不需要字符串连接而且不会导致暂时不需要的字符串消耗。而是以<strong>一个以占位符和以参数传递实际值的模板格式下写日志信息</strong>。你可能会在想万一我有很多个参数怎么办？那么你可以选择使用变量参数版本的日志方法或者用以Object数组传递。这是一个相当的方便和高效方法的打日志方法。记住，在生产最终日志信息的字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了CPU去处理字符串连接命令的时间。这里是使用SLF4J日志方法的代码，来自于<code>slf4j-log4j12-1.6.1.jar</code>中的<code>Log4j</code>的适配器类<code>Log4jLoggerAdapter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object arg1, Object arg2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">        FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);</div><div class="line">        logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="怎么用SLF4J做Log4J的日志记录"><a href="#怎么用SLF4J做Log4J的日志记录" class="headerlink" title="怎么用SLF4J做Log4J的日志记录"></a>怎么用SLF4J做Log4J的日志记录</h3><p>为了使用SLF4J，你不仅需要包含SLF4J的<code>API jar</code>包，例如 <code>slf4j-api-1.6.1.jar</code>，还需要相关Jar包，这取决于你在后台使用的日志类库。如果你想要使用和Log4J 一起使用SLF4J ，Simple Logging Facade for Java,，你需要包含以下的Jar包在你的classpath中，取决于哪个SLF4J和你在使用的Log4J的版本。例如：</p>
<ul>
<li><code>slf4j-api-1.5.8.jar</code> – JAR for SLF4J API</li>
<li><code>log4j-1.2.16.jar</code> – JAR for Log4J API</li>
<li><code>slf4j-log4j12-1.5.8.jar</code> – Log4J Adapter for SLF4J</li>
</ul>
<p>如果你在使用Maven去管理你的项目依赖，你只需要包含SLF4J JAR包，maven会包含它的依赖的相关包。为了和SLF4J一起中使用Log4J，你可以包含以下的依赖在你项目中的pom.xml。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4js</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Slf4js.class);</div><div class="line">    Integer t;</div><div class="line">    Integer oldT;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemperature</span><span class="params">(Integer temperature)</span> </span>&#123;</div><div class="line">        oldT = t;</div><div class="line">        t = temperature;</div><div class="line">        logger.error(<span class="string">" Temperature set to &#123;&#125;. Old temperature was &#123;&#125;. "</span>, t, oldT);</div><div class="line">        <span class="keyword">if</span> (temperature.intValue() &gt; <span class="number">50</span>) &#123;</div><div class="line">            logger.info(<span class="string">" Temperature has risen above 50 degrees. "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Slf4js slf4j = <span class="keyword">new</span> Slf4js();</div><div class="line">        slf4j.setTemperature(<span class="number">1</span>);</div><div class="line">        slf4j.setTemperature(<span class="number">55</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><strong>1. 问题一</strong></p>
<p>描述<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalAccessError: tried to access field org.slf4j.impl.Static..</div><div class="line">java.lang.IllegalAccessError: tried to access field org.slf4j.impl.StaticLoggerBinder.SINGLETON from <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">slf4j</span>.<span class="title">LoggerFactory</span></span></div></pre></td></tr></table></figure></p>
<p>问题原因：jar文件版本冲突</p>
<p>类 <code>org.slf4j.impl.StaticLoggerBinder</code>在<code>slf4j-api</code> 中是类的公有静态变量: </p>
<p><code>public static final StaticLoggerBinder SINGLETON = new StaticLoggerBinder();</code></p>
<p>而在<code>slf4j-log4j12</code>（slf4j-nop.jar, slf4j-simple.jar, slf4j-log4j12.jar, slf4j-jdk14.jar or logback-classic.jar其中之一）中确是私有变量: </p>
<p><code>private static final StaticLoggerBinder SINGLETON = new StaticLoggerBinder();</code></p>
<p>解决方案：</p>
<p>1.修改slf的源代码，将这个变量有私有改为公有，再打包，问题可解决。</p>
<p>2.slf4j-api.jar 删除，再导入同版本的slf4j-api-1.5.6.jar 和slf4j-log4j12-1.5.6.jar ，问题可解决。</p>
<p><strong>问题二</strong></p>
<p>问题描述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log4j:WARN No appenders could be found for logger (xxx.yyy.zzz).</div><div class="line">log4j:WARN Please initialize the log4j system properly.</div></pre></td></tr></table></figure></p>
<p>问题解决：</p>
<p>在src下面新建file名为<code>log4j.properties</code>内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Configure logging for testing: optionally with log file</div><div class="line">log4j.rootLogger=WARN, stdout</div><div class="line"># log4j.rootLogger=WARN, stdout, logfile</div><div class="line"></div><div class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n</div><div class="line"></div><div class="line">log4j.appender.logfile=org.apache.log4j.FileAppender</div><div class="line">log4j.appender.logfile.File=target/spring.log</div><div class="line">log4j.appender.logfile.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</div></pre></td></tr></table></figure></p>
<p>其他情形下的问题解决：</p>
<p>在Eclipse中开发相关项目时,在控制台经常看到如下信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log4j:WARN No appenders could be found for logger</div><div class="line">log4j:WARN Please initialize the log4j system properly.</div></pre></td></tr></table></figure></p>
<p>此处输出信息并不是错误信息而仅只是警告信息,因为log4j无法输出日志,log4j是一个日志输入软件包。可以将Struts或Hibernate等压缩包解压，内有log4j.properties文件，将它复制到项目src文件夹或将<code>log4j.properties</code>放到 <code>\WEB-INF\classes</code>文件夹中即可。</p>
<p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p>
<p>做一个SSH项目，tomcat启动时出现以下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log4j:WARN No appenders could be found for logger (org.springframework.web.context.ContextLoader).</div><div class="line">log4j:WARN Please initialize the log4j system properly.</div></pre></td></tr></table></figure></p>
<p>在网上查了一下，多是说把<code>ContextLoaderListener</code>改为<code>SpringContextServlet</code>，但我这样改了没用。后来在一个英文网站上看到一个遇到同样问题的帖子，他是这样改的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/config/log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>······<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 定义LOG4J监听器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></div><div class="line">org.springframework.web.util.Log4jConfigListener</div><div class="line">   <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样改了问题就解决了，不用再修改<code>ContextLoaderListener</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在你的开源或内部类库中使用SLF4J会使得它独立于任何一个特定的日志实现，这意味着不需要管理多个日志配置或者多个日志类库。</p>
<p>SLF4J提供了基于占位符的日志方法，不需要检查isDebugEnabled(), isInfoEnabled()等等，提高了代码可读性。</p>
<p>通过使用SLF4J的日志方法，你可以延迟构建日志信息（Srting）的开销，直到你真正需要，这对于内存和CPU都是高效的。</p>
<p>作为附注，更少的暂时的字符串意味着垃圾回收器（Garbage Collector）能够做更多的工作，这意味着你的应用程序有为更好的吞吐量和性能。</p>
<p>这些好处只是冰山一角，你将在开始使用SL4J和阅读其中代码的时候知道更多的好处，建议使用SLF4J做日志而不是使用包括Log4J在内的其他日志API。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一个Java程序员都知道日志对于任何一个Java应用程序，尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库如&lt;code&gt;java.util.logging、Apache log4j、logback&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将学习为什么使用&lt;code&gt;SLF4J&lt;/code&gt;比&lt;code&gt;log4j&lt;/code&gt;或者&lt;code&gt;java.util.logging&lt;/code&gt;要优秀。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="技术" scheme="http://chuanqiang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SLF4J" scheme="http://chuanqiang.github.io/tags/SLF4J/"/>
    
      <category term="日志" scheme="http://chuanqiang.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>罗永浩『改变命运的演讲能力』听课笔记</title>
    <link href="http://chuanqiang.github.io/2017/02/25/luoyonghao-speeck/"/>
    <id>http://chuanqiang.github.io/2017/02/25/luoyonghao-speeck/</id>
    <published>2017-02-25T09:28:26.000Z</published>
    <updated>2017-02-25T09:44:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>老罗是一个我觉得很有趣又十分佩服的人，这段时间在播客上听一个关于他的电台，叫做『老罗锤子FM』，里面不但有之前他在网上流传的一些音频资料，而且会更新一些他发布会、演讲以及参加交流活动的现场录音。昨天在下班的地铁上听了老罗的『改变命运的演讲能力』的音频，觉得受益颇多，于是在网上找到了这篇不错的听课笔记，加以整理分享至此。</p>
<a id="more"></a>
<h3 id="演讲恐惧症"><a href="#演讲恐惧症" class="headerlink" title="演讲恐惧症"></a>演讲恐惧症</h3><ol>
<li>再熟练的人，也有演讲恐惧症，有不安恐惧紧张，正因为如此痛苦，才具有价值。</li>
<li>演讲很好的人，很多都是深怕自己把演讲搞砸的人（我觉得这个程度肯定不是怕得要死，不然也会出问题，可能话都说不出来了）</li>
<li>消除演讲恐惧的方式，唯一的方式，就是多讲，别无选择，不要相信演讲之前把观众想象成裸体之类的。</li>
<li>除了多讲之外，一个很有帮助的技巧就是，多用录音或录像的方式，来了解自己训练到一个什么样的程度，也可以把自己的录音或录像给一些信任的人让他们去评价。</li>
<li>成功的人，不畏惧做自己畏惧的事情。</li>
</ol>
<h3 id="老罗对演讲的理解"><a href="#老罗对演讲的理解" class="headerlink" title="老罗对演讲的理解"></a>老罗对演讲的理解</h3><ol>
<li>演讲的本质，不是一个正常的沟通和交流，而是一场表演，再像很自然地和朋友平常交流，也是刻意的。</li>
<li>演讲就是表演，但表演也可以是真诚的。</li>
<li>演讲的天分和后期的努力的比重，如果要成为专业演讲家，则天分至少一半。如果只需要把演讲的能力比一般人强，靠努力训练足够了。</li>
<li>做自己有激情的事，那么演讲中的激情就是真实的。</li>
<li>演讲的基本道理，所有演讲的技巧辅助手段方式都替代不了内容本身。</li>
<li>不要长期尝试感觉不到激情与幸福的职业。</li>
<li>一直假装自己很兴奋不可能，但在演讲的头十分钟假装自己很兴奋，装着装着自己也就真的兴奋了。</li>
<li>有一种精神药物可以让你一整天都精神抖擞，副作用很少或没有，可以托认识的医生进行购买。</li>
</ol>
<h3 id="演讲的准备"><a href="#演讲的准备" class="headerlink" title="演讲的准备"></a>演讲的准备</h3><ol>
<li>演讲的准备时间：如果是大型演讲一个多小时，从准备大纲充实内容制作幻灯片等，不少于100个小时，就是一百倍。</li>
<li>罗永浩准备2个小时多一点的演讲，也需要200个小时。</li>
<li>即使是15分钟的会议报告，你也需要8-10小时去准备，这样才可以让上司同事感觉不错。</li>
</ol>
<h3 id="演讲技巧"><a href="#演讲技巧" class="headerlink" title="演讲技巧"></a>演讲技巧</h3><ol>
<li>要有数据。</li>
<li>要会吹牛逼。人们不是不喜欢听别人，只是不喜欢吹牛逼吹的不好看的。</li>
<li>要有故事，作为开场白和阐述一个理论。</li>
<li>要有画面，人是视觉动物。</li>
<li>要有问题，调动大家的胃口，把握现场节奏。</li>
<li>要有情感。</li>
<li>要善于自嘲，不然老是有包袱。</li>
<li>可以不断重复已经使用过的技巧（比如提出问题调动胃口），但你得保证每次质量都要高。恐怖片的套路都是一样的，不还是被吓到。</li>
<li>演讲最好采用三段式。每段讲完就要有一句总结的话，便于观众加深记忆。</li>
<li>在结尾，把演讲的境界提高。</li>
<li>逻辑很重要。对于有良好教育的人来说，逻辑性严密是必要的。</li>
<li>标题党。这个词是中性词。</li>
<li>错误把一个小圈子里面开玩笑的事情理解为公众都知道的，这是一个典型的错误。就算要讲，也要讲的若无其事，同时观察观众的反应。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老罗是一个我觉得很有趣又十分佩服的人，这段时间在播客上听一个关于他的电台，叫做『老罗锤子FM』，里面不但有之前他在网上流传的一些音频资料，而且会更新一些他发布会、演讲以及参加交流活动的现场录音。昨天在下班的地铁上听了老罗的『改变命运的演讲能力』的音频，觉得受益颇多，于是在网上找到了这篇不错的听课笔记，加以整理分享至此。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="http://chuanqiang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="罗永浩" scheme="http://chuanqiang.github.io/tags/%E7%BD%97%E6%B0%B8%E6%B5%A9/"/>
    
      <category term="演讲" scheme="http://chuanqiang.github.io/tags/%E6%BC%94%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础之多线程</title>
    <link href="http://chuanqiang.github.io/2017/02/20/thread/"/>
    <id>http://chuanqiang.github.io/2017/02/20/thread/</id>
    <published>2017-02-20T13:32:22.000Z</published>
    <updated>2017-02-20T13:34:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍了 Java 开发中多线程的相关知识，并列举了常用的线程池。</p>
<a id="more"></a>
<p><strong>进程</strong>：正在执行中的程序，其实是应用程序在内存中运行的那片空间。</p>
<p><strong>线程</strong>：进程中的一个执行单元，负责进程中程序的执行。一个进程中至少有一个线程，也可以有多个线程，此时称为多线程程序。</p>
<p><strong>硬盘</strong>：持久化存储数据区域(关机后数据仍在)。</p>
<p><strong>内存</strong>：临时性存储数据区域(关机后数据消失)，提高性能。</p>
<p>CPU处理程序是通过快速切换完成的，与我们来说是随机的；多线程的使用可以合理的使用CPU资源，如果线程过多会导致降低性能。</p>
<h2 id="Thread-的相关方法"><a href="#Thread-的相关方法" class="headerlink" title="Thread 的相关方法"></a>Thread 的相关方法</h2><ul>
<li><code>Thread.currentThread().getName()</code>: 获得当前线程的名称(主线程:main；自定义线程:Thread-N)。</li>
<li><code>isAlive</code>:判断线程是否未终止</li>
<li><code>getPriority</code>:获得线程的优先级数值</li>
<li><code>setPriority</code>:设置线程的优先级数值</li>
<li><code>setName</code>:设置线程的名字</li>
</ul>
<h2 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h2><h3 id="一、继承Thread类"><a href="#一、继承Thread类" class="headerlink" title="一、继承Thread类"></a>一、继承Thread类</h3><ol>
<li>继承<code>Thread</code>类</li>
<li>重写<code>Thread</code>的<code>run</code>方法。</li>
<li>创建子类对象，即线程对象</li>
<li>调用start方法，开启线程并让线程执行，同时告诉jvm去调用<code>run</code>方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">			System.out.println(<span class="string">"====="</span>+ Thread.currentThread().getName() +<span class="string">"====="</span> + <span class="keyword">this</span>.name + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// 创建了两个线程对象</span></div><div class="line">		Demo d1 = <span class="keyword">new</span> Demo(<span class="string">"张三"</span>);</div><div class="line">		Demo d2 = <span class="keyword">new</span> Demo(<span class="string">"李四"</span>);</div><div class="line">		d2.start();<span class="comment">//将d2线程开启</span></div><div class="line">		d1.run();<span class="comment">// 由主线程负责</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>线程对象调用<code>run</code>方法和调用<code>start</code>方法的区别？<br>调用<code>run</code>方法不开启线程,仅是对象调用方法.<br>调用<code>start</code>开启线程,并让jvm调用<code>run</code>方法在开启的线程中执行.</p>
</blockquote>
<h4 id="多线程内存"><a href="#多线程内存" class="headerlink" title="多线程内存"></a>多线程内存</h4><ul>
<li>多线程执行时,在栈内存中,每一个线程都有一片属于自己的栈内存空间,进行方法的压栈和弹栈.</li>
<li>当执行线程的任务结束了,线程自动在栈内存中释放.</li>
<li>当所有的执行线程都结束了,进程才结束</li>
</ul>
<h3 id="二、实现-Runnable-接口"><a href="#二、实现-Runnable-接口" class="headerlink" title="二、实现 Runnable 接口"></a>二、实现 Runnable 接口</h3><ol>
<li>定义类实现<code>Runnable</code>接口: 避免继承Thread类的单继承局限性</li>
<li>覆盖接口中的<code>run</code>方法。将线程任务代码定义到<code>run</code>方法中</li>
<li>创建<code>Thread</code>类的对象，并将<code>Runnable</code>接口的子类对象作为参数传递给<code>Thread</code>类的构造函数。因为线程被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给THread的构造函数。这样，线程对象创建时就可以明确要运行的线程任务。</li>
<li>调用<code>Thread</code>类的<code>start</code>方法开启线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">   <span class="comment">// 覆盖了接口Runnable中的run方法 </span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">			System.out.println(<span class="string">"====="</span>+ Thread.currentThread().getName() +<span class="string">"====="</span> + <span class="keyword">this</span>.name + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	   <span class="comment">// 创建Runnable子类的对象，注意它并不是线程对象</span></div><div class="line">		Demo d1 = <span class="keyword">new</span> Demo(<span class="string">"张三"</span>);</div><div class="line">		Demo d2 = <span class="keyword">new</span> Demo(<span class="string">"李四"</span>);</div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread(d1); </div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread(d2); </div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		System.out.println(Thread.currentThread().getName());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>实现Runnable接口避免了单继承的局限性，所以较为常用。</li>
<li>实现Runnable接口的方式，更加符合面向对象。线程分为两部分，一部分线程对象，一部分线程任务。<ul>
<li>继承Thread类，线程对象和任务耦合在一起，一旦创建Thread子类对象，即使线程对象，又是线程任务。</li>
<li>实现Runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口，实现了解耦。</li>
</ul>
</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="http://oeckzejn4.bkt.clouddn.com/blog/20170206-224342984.jpg" alt=""></p>
<h2 id="多线程的安全问题"><a href="#多线程的安全问题" class="headerlink" title="多线程的安全问题"></a>多线程的安全问题</h2><p>由于线程的随机性，会出现多线程的安全问题。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>线程任务操作共享的数据</li>
<li>线程任务操作数据的运算有多个</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="1、synchronized-同步代码块"><a href="#1、synchronized-同步代码块" class="headerlink" title="1、synchronized 同步代码块"></a>1、synchronized 同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(对象)&#123;</div><div class="line">    <span class="comment">// 需要被同步的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>原理</strong></p>
<p>线程1读到<code>synchronized</code>，会找后面括号中的对象(可任意，一般写<code>this</code>)并拿到该对象，之后往下执行。当线程2读到<code>synchronized</code>的时候，也会找后面括号中的对象，发现被线程1拿走了，所以线程2进不来了。直到线程1执行完<code>synchronized</code>代码块并释放对象之后，线程2才能继续执行。(对象相当于锁)–&gt;火车上的卫生间</p>
<p><strong>注意</strong>:必须保证多个线程在同步中使用的同一个锁，即<code>synchronized</code>后面括号中为同一个对象</p>
<p> <strong>同步弊端</strong>：降低了程序性能。</p>
<h4 id="2、-同步函数"><a href="#2、-同步函数" class="headerlink" title="2、 同步函数"></a>2、 同步函数</h4><p>同步函数使用的锁是固定的<code>this</code>。当线程任务只需要一个同步时完全可以使用同步函数。<br>同步代码块使用的锁是任意对象。当线程中需要多个同步时 ，必须通过锁来区分(较为常用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">// 需要被同步的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong><code>static</code>同步函数<code>public static synchronized void method(){}</code>，使用的锁不是<code>this</code>，而是字节码文件对象(<code>类名.class</code>)。因为万物皆对象，字节码文件也被视为对象存在。因此相应的<code>synchronized</code>代码块后的对象也要用<code>类名.class</code>:<code>synchronized(类名.class){}</code>.</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>既然是多线程的问题，必然发生在线程任务内</li>
<li>分析线程任务内是否有共享数据</li>
<li>是否有对数据进行多次运算</li>
</ul>
<h3 id="懒汉式线程安全问题"><a href="#懒汉式线程安全问题" class="headerlink" title="懒汉式线程安全问题"></a>懒汉式线程安全问题</h3><p><strong>恶汉式</strong>:线程安全，调用率高，但是不能延时加载，类初始化时，立即加载这个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo01 instance = <span class="keyword">new</span> Demo01();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo01</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>懒汉式</strong>:可以延时加载，存在线程问题，可以加锁，并且为了兼顾效率，再加一次判断，减少判断锁的次数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(Single.class)&#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                instance = <span class="keyword">new</span> Single();</div><div class="line">             &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他同步，容易引发死锁。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Thread_0</span></div><div class="line"><span class="keyword">synchronized</span>(obj1)&#123;</div><div class="line">    <span class="comment">//Thread-0 obj1--&gt;</span></div><div class="line">    <span class="keyword">synchronized</span>(obj2)&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Thread_1</span></div><div class="line"><span class="keyword">synchronized</span>(obj2)&#123;</div><div class="line">    <span class="comment">//Thread-1 obj2--&gt;</span></div><div class="line">    <span class="keyword">synchronized</span>(obj1)&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个死锁程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Test t1 = <span class="keyword">new</span> Test(<span class="keyword">true</span>);</div><div class="line">		Test t2 = <span class="keyword">new</span> Test(<span class="keyword">false</span>);</div><div class="line">		Thread t11 = <span class="keyword">new</span> Thread(t1);</div><div class="line">		Thread t22 = <span class="keyword">new</span> Thread(t2);</div><div class="line">		t11.start();</div><div class="line">		t22.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	Test(<span class="keyword">boolean</span> flag) &#123;</div><div class="line">		<span class="keyword">this</span>.flag = flag;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (flag) &#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				<span class="keyword">synchronized</span> (MyLock.LOCKA) &#123;</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">"...if...lock a"</span>);</div><div class="line">					<span class="keyword">synchronized</span> (MyLock.LOCKB) &#123;</div><div class="line">						System.out.println(Thread.currentThread().getName() + <span class="string">"...if...lock b"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				<span class="keyword">synchronized</span> (MyLock.LOCKB) &#123;</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">"...if...lock b"</span>);</div><div class="line">					<span class="keyword">synchronized</span> (MyLock.LOCKA) &#123;</div><div class="line">						System.out.println(Thread.currentThread().getName() + <span class="string">"...if...lock a"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCKA = <span class="keyword">new</span> Object();</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCKB = <span class="keyword">new</span> Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="多线程通讯"><a href="#多线程通讯" class="headerlink" title="多线程通讯"></a>多线程通讯</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>这是多线程中最为常见的案例(重要)<br>生产者和消费者同时执行，需要多线程；但是任务却不相同，处理的资源是相同的:<strong>线程间的通信</strong></p>
<p>生产消费实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumer</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Resource r = <span class="keyword">new</span> Resource();</div><div class="line">		Produce produce = <span class="keyword">new</span> Produce(r);</div><div class="line">		Consumer consumer = <span class="keyword">new</span> Consumer(r);</div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread(produce);</div><div class="line">		Thread t11 = <span class="keyword">new</span> Thread(produce);</div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread(consumer);</div><div class="line">		Thread t22 = <span class="keyword">new</span> Thread(consumer);</div><div class="line">		<span class="comment">// 开启多个生产多个消费</span></div><div class="line">		t1.start();</div><div class="line">		t11.start();</div><div class="line">		t2.start();</div><div class="line">		t22.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 资源</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 生产</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (flag) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.name = name + num;</div><div class="line">		num++;</div><div class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">"---生产者---"</span> + <span class="keyword">this</span>.name);</div><div class="line">		flag = <span class="keyword">true</span>;</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 消费</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (!flag) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">"---消费者---"</span> + <span class="keyword">this</span>.name);</div><div class="line">		flag = <span class="keyword">false</span>;</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生产者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Produce</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Resource r;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Produce</span><span class="params">(Resource r)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.r = r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">50</span>; i &lt; <span class="number">200</span>; i++) &#123;</div><div class="line">			r.set(<span class="string">"面包"</span>); <span class="comment">// 开始生产</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 消费者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Resource r;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Resource r)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.r = r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</div><div class="line">			r.get(); <span class="comment">// 开始消费</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>:</p>
<ul>
<li>当多个生产消费的时候，为防止被唤醒的线程没有判断标记，要用<code>while</code>判断标记，而不是<code>if</code>。</li>
<li>用<code>while</code>时会出现死锁，因为本方唤醒了本方,希望唤醒对方，所以使用<code>notifyAll</code>方法。</li>
</ul>
<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><ul>
<li><code>wait()</code>: 会让线程处于等待状态，将线程临时存进了线程池中</li>
<li><code>notify()</code>: 会唤醒线程池中的任意一个等待线程。</li>
<li><code>notifyAll()</code>: 会唤醒线程池中所有的等待线程。</li>
</ul>
<p><strong>注意</strong>: </p>
<ul>
<li>这些方法必须使用在同步中，因为必须要标识<code>wait</code>、<code>notify</code>等方法所使用的锁。同一个锁上的<code>notify</code>，只能唤醒该锁上的<code>wait</code>方法。</li>
<li>这些方法必须标识所属的锁，而锁可以是任意对象，任意对象可以调用的方法必须是Object的方法，所以<strong>这些方法定义在Object类中</strong></li>
</ul>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>在 JDK 1.5 之后，<code>Lock</code> 实现提供了比使用 <code>synchronized</code> 方法和语句可获得的更广泛的锁定操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lock l = ...; </div><div class="line">     l.lock();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="comment">// access the resource protected by this lock</span></div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         l.unlock(); <span class="comment">// 因为必须要释放锁，所以放到finally中</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>因为必须要释放锁，所以<code>lock.lock()</code>放到<code>finally</code> 块中。</p>
<p>之前用<code>synchronized</code>同步，锁可以是任意对象，并且锁对象和锁的方法是在一块的(Object 对象中的<code>object()</code>、<code>notify()</code>、<code>notifyAll()</code>方法)，而在Lock中把所有的监视器方法封装到<code>Condition</code> 对象中，实现了锁对象和监视器方法(锁方法)的分离，更加的面向对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 获得锁对象</span></div><div class="line">Condition con = lock.newCondition(); <span class="comment">// 获得lock上的监视器方法对象</span></div><div class="line">lock.lock();    <span class="comment">// 得到锁</span></div><div class="line">con.await();    <span class="comment">//  让线程处于等待状态</span></div><div class="line">con.signal();   <span class="comment">// 唤醒任意一个等待的线程</span></div><div class="line">con.singnalAll(); <span class="comment">// 唤醒所有等待的线程</span></div><div class="line">lock.unlock();  <span class="comment">// 释放锁</span></div></pre></td></tr></table></figure></p>
<p>一个实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">   <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </div><div class="line">   <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </div><div class="line"></div><div class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</div><div class="line">   <span class="keyword">int</span> putptr, takeptr, count;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">     lock.lock();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">while</span> (count == items.length) </div><div class="line">         notFull.await();</div><div class="line">       items[putptr] = x; </div><div class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</div><div class="line">       ++count;</div><div class="line">       notEmpty.signal();</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       lock.unlock();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">     lock.lock();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>) </div><div class="line">         notEmpty.await();</div><div class="line">       Object x = items[takeptr]; </div><div class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</div><div class="line">       --count;</div><div class="line">       notFull.signal();</div><div class="line">       <span class="keyword">return</span> x;</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       lock.unlock();</div><div class="line">     &#125;</div><div class="line">   &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="多线程的细节问题"><a href="#多线程的细节问题" class="headerlink" title="多线程的细节问题"></a>多线程的细节问题</h2><h3 id="1-sleep-和-wait-方法的异同点"><a href="#1-sleep-和-wait-方法的异同点" class="headerlink" title="1. sleep 和 wait 方法的异同点"></a>1. sleep 和 wait 方法的异同点</h3><ul>
<li>相同点<ul>
<li>都可以让线程处于冻结状态</li>
</ul>
</li>
<li>不同点<ul>
<li>sleep 必须指定时间；wait 可以指定时间，也可以不指定时间</li>
<li>sleep 时间到，线程处于临时阻塞或者运行；wait 如果没指定时间，必须通过notify 或者 notifyAll唤醒。</li>
<li>sleep 不一定非要定义在同步中；wait 必须定义在同步中。</li>
<li>都定义在同步中<ul>
<li>线程执行到 sleep，不会释放所</li>
<li>线程执行到 wait，会释放锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-线程如何停止"><a href="#2-线程如何停止" class="headerlink" title="2. 线程如何停止"></a>2. 线程如何停止</h3><p>所谓线程结束，就是让线程任务代码完成，<code>run</code>方法结束。</p>
<ul>
<li>stop  方法(过时):具有固定的不安全性，用<code>Thread.stop</code>来终止线程，将释放它已经锁定的所有监视器。</li>
<li>定义循环，控制住循环就行了</li>
<li>如果目标线程等待很长时间(处于冻结状态)，应用<code>interrupt</code>方法中断该线程(将线程的冻结状态清除，让线程重新获得cpu的执行资格)，并且收到一个<code>InterruptException</code>，在<code>catch</code>块中捕获，在异常处理中改变标记，让循环结束。</li>
</ul>
<p>Interrupt 实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> thread;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (flag) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + e.toString());</div><div class="line">				changeFlag();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">		flag = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Task d = <span class="keyword">new</span> Task();</div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread(d,<span class="string">"线程1"</span>);</div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread(d,<span class="string">"线程2"</span>);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (++x == <span class="number">50</span>) &#123;</div><div class="line">				<span class="comment">// d.changeFlag();</span></div><div class="line">				t1.interrupt();</div><div class="line">				t2.interrupt();</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName());</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"over..."</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-守护线程"><a href="#3-守护线程" class="headerlink" title="3. 守护线程"></a>3. 守护线程</h3><p>守护线程，可以理解为后台线程，一般创建的为前台线程，前后台运行线程的时候都是一样的，获取cpu的执行权限。但是结束的时候有些不同，前台线程和后台线程只要<code>run</code>方法结束，线程结束，<strong>但是在所有前台线程结束的时候，后台线程无论处于什么状态都会结束，从而进程结束。进程结束依赖的都是前台线程。</strong></p>
<p><strong>方法</strong>: <code>setDaemon(boolean on)</code></p>
<ul>
<li>该方法必须在线程启动前调用:<code>t.setDaemon(true);  t.start; // t 线程设置为了守护线程</code></li>
<li><code>on</code>如果为<code>true</code>，该线程标记为守护线程</li>
</ul>
<h3 id="4-线程的优先级"><a href="#4-线程的优先级" class="headerlink" title="4. 线程的优先级"></a>4. 线程的优先级</h3><p><code>Thread.currentThread.toString</code>: 返回该线程的字符串表示形式，包括『线程名称』、『优先级』、『线程组』</p>
<p><strong>优先级</strong>:</p>
<ul>
<li>用数字标识的<code>0-10</code>；其中默认的初始化优先级是5；</li>
<li>最明显的三个优先级 : 1，5，10。</li>
<li>Thread.MAX_PRIORITY 线程可以具有的最高优先级。 </li>
<li>Thread.MIN_PRIORITY  线程可以具有的最低优先级。 </li>
<li>Thread.NORM_PRIORITY  分配给线程的默认优先级。 </li>
<li>得到线程的优先级:<code>getPriority()</code></li>
<li>更改线程的优先级:<code>setPriority()</code></li>
</ul>
<h3 id="5-线程组"><a href="#5-线程组" class="headerlink" title="5. 线程组"></a>5. 线程组</h3><p><code>ThreadGroup</code>: 可以通过Thread构造函数明确新线程对象所属的线程组</p>
<p>线程组的好处: 可以对多个同组线程，进行统一的操作。默认都属于main线程。</p>
<h3 id="6-join-和-yield-方法"><a href="#6-join-和-yield-方法" class="headerlink" title="6. join() 和 yield() 方法"></a>6. join() 和 yield() 方法</h3><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a>join() 方法</h4><p>用于临时加入一个运算的线程。让该线程执行完，程序才会执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Demo d  = <span class="keyword">new</span> Demo();</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(d);</div><div class="line">t1.start();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">// 主线程执行到这里，知道t1要加入执行，主线程释放了执行权(仅仅是释放，至于执行权给谁，有cpu随机决定)</span></div><div class="line">    <span class="comment">// 主线程的执行资格处于冻结状态，直至t1线程执行完恢复</span></div><div class="line">    t1.join;</div><div class="line">    &#125;<span class="keyword">catch</span>(InterruptException e)&#123;&#125;</div><div class="line">t2.start();</div></pre></td></tr></table></figure></p>
<h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield() 方法"></a>yield() 方法</h4><p>暂停当前正在执行的线程对象，并执行其他线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</div><div class="line">            <span class="comment">// 线程临时停止，将执行权释放，让其他线程有机会获得执行权</span></div><div class="line">            Thread.yield();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="线程中匿名内部类使用"><a href="#线程中匿名内部类使用" class="headerlink" title="线程中匿名内部类使用"></a>线程中匿名内部类使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</div><div class="line">        code....</div><div class="line">    &#125;    </div><div class="line">&#125;;</div><div class="line"><span class="keyword">new</span> Thread(r).start();</div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</div><div class="line">        code....</div><div class="line">&#125;    </div><div class="line">&#125;.start();</div></pre></td></tr></table></figure>
<p><strong>哪一个执行？</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"runnable run"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;)&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"subthread run"</span>); <span class="comment">// 执行</span></div><div class="line">		&#125;</div><div class="line">	&#125;.start();</div></pre></td></tr></table></figure></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>自JDK5之后，Java推出了一个<strong>并发包</strong>：<code>java.util.concurrent</code>，在Java开发中，我们接触到了好多池的技术，<code>String类的对象池、Integer的共享池、连接数据库的连接池、Struts1.3的对象池</code>等等，<strong>池的最终目的都是节约资源</strong>，以更小的开销做更多的事情，从而提高性能。</p>
<p>我们的web项目都是部署在服务器上，浏览器端的每一个request就是一个线程，那么服务器需要并发的处理多个请求，就需要线程池技术，下面来看一下Java并发包下如何创建线程池。</p>
<ol>
<li>创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">// 创建可以容纳3个线程的线程池</span></div></pre></td></tr></table></figure>
<ol>
<li>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService threadPool = Executors.newCachedThreadPool();// 线程池的大小会根据执行的任务数动态分配</div></pre></td></tr></table></figure>
<ol>
<li>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ExecutorService threadPool = Executors.newSingleThreadExecutor();</div><div class="line">// 创建单个线程的线程池，如果当前线程在执行任务时突然中断，则会创建一个新的线程替代它继续执行任务</div></pre></td></tr></table></figure>
<ol>
<li>创建一个可安排在给定延迟后运行命令或者定期地执行的线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(3); // 效果类似于Timer定时器</div></pre></td></tr></table></figure>
</li>
</ol>
<p>每种线程池都有不同的使用场景，下面看一下这四种线程池使用起来有什么不同。</p>
<ol>
<li>FixedThreadPool</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ExecutorService;  </div><div class="line">import java.util.concurrent.Executors;  </div><div class="line">publicclass ThreadPoolTest &#123;  </div><div class="line">public static void main(String[] args) &#123;  </div><div class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(3);  </div><div class="line">    for(int i = 1; i &lt; 5; i++) &#123;  </div><div class="line">        final int taskID = i;  </div><div class="line">        threadPool.execute(new Runnable() &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                for(int i = 1; i &lt; 5; i++) &#123;  </div><div class="line">                    try &#123;  </div><div class="line">                        Thread.sleep(20);// 为了测试出效果，让每次任务执行都需要一定时间</div><div class="line">                    &#125; catch (InterruptedException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                        System.out.println(&quot;第&quot; + taskID + &quot;次任务的第&quot; + i + &quot;次执行&quot;);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;);  </div><div class="line">        &#125;  </div><div class="line">        threadPool.shutdown();// 任务执行完毕，关闭线程池</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">第1次任务的第1次执行  </div><div class="line">第2次任务的第1次执行  </div><div class="line">第3次任务的第1次执行  </div><div class="line">第2次任务的第2次执行  </div><div class="line">第3次任务的第2次执行  </div><div class="line">第1次任务的第2次执行  </div><div class="line">第3次任务的第3次执行  </div><div class="line">第1次任务的第3次执行  </div><div class="line">第2次任务的第3次执行  </div><div class="line">第3次任务的第4次执行  </div><div class="line">第2次任务的第4次执行  </div><div class="line">第1次任务的第4次执行  </div><div class="line">第4次任务的第1次执行  </div><div class="line">第4次任务的第2次执行  </div><div class="line">第4次任务的第3次执行  </div><div class="line">第4次任务的第4次执行</div></pre></td></tr></table></figure></p>
<p>上段代码中，创建了一个固定大小的线程池，容量为3，然后循环执行了4个任务，由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4个任务，在<code>FixedThreadPool</code>中，有一个固定大小的池，如果当前需要执行的任务超过了池大小，那么多余的任务等待状态，直到有空闲下来的线程执行任务，而当执行的任务小于池大小，空闲的线程也不会去销毁。</p>
<ol>
<li>CachedThreadPool</li>
</ol>
<p>上段代码其它地方不变，将<code>newFixedThreadPool(3)</code>方法换成<code>newCachedThreadPool()</code>方法。</p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">第3次任务的第1次执行  </div><div class="line">第4次任务的第1次执行  </div><div class="line">第1次任务的第1次执行  </div><div class="line">第2次任务的第1次执行  </div><div class="line">第4次任务的第2次执行  </div><div class="line">第3次任务的第2次执行  </div><div class="line">第2次任务的第2次执行  </div><div class="line">第1次任务的第2次执行  </div><div class="line">第2次任务的第3次执行  </div><div class="line">第3次任务的第3次执行  </div><div class="line">第1次任务的第3次执行  </div><div class="line">第4次任务的第3次执行  </div><div class="line">第2次任务的第4次执行  </div><div class="line">第4次任务的第4次执行  </div><div class="line">第3次任务的第4次执行  </div><div class="line">第1次任务的第4次执行</div></pre></td></tr></table></figure></p>
<p>可见，4个任务是交替执行的，<code>CachedThreadPool</code>会创建一个缓存区，将初始化的线程缓存起来，如果线程有可用的，就使用之前创建好的线程，如果没有可用的，就新创建线程，终止并且从缓存中移除已有60秒未被使用的线程。</p>
<ol>
<li>SingleThreadExecutor        </li>
</ol>
<p>上段代码其它地方不变，将<code>newFixedThreadPool</code>方法换成<code>newSingleThreadExecutor</code>方法。   </p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">第1次任务的第1次执行  </div><div class="line">第1次任务的第2次执行  </div><div class="line">第1次任务的第3次执行  </div><div class="line">第1次任务的第4次执行  </div><div class="line">第2次任务的第1次执行  </div><div class="line">第2次任务的第2次执行  </div><div class="line">第2次任务的第3次执行  </div><div class="line">第2次任务的第4次执行  </div><div class="line">第3次任务的第1次执行  </div><div class="line">第3次任务的第2次执行  </div><div class="line">第3次任务的第3次执行  </div><div class="line">第3次任务的第4次执行  </div><div class="line">第4次任务的第1次执行  </div><div class="line">第4次任务的第2次执行  </div><div class="line">第4次任务的第3次执行  </div><div class="line">第4次任务的第4次执行</div></pre></td></tr></table></figure></p>
<p>4个任务是顺序执行的，<code>SingleThreadExecutor</code>得到的是一个单个的线程，这个线程会保证你的任务执行完成，如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和<code>newFixedThreadPool(1)</code>不同。</p>
<p>4.ScheduledThreadPool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.Executors;</div><div class="line">import java.util.concurrent.ScheduledExecutorService;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line">public class ThreadPoolTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(1);</div><div class="line">        // 5秒后执行任务</div><div class="line">        schedulePool.schedule(new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(&quot;爆炸&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;, 5, TimeUnit.SECONDS);</div><div class="line">        // 5秒后执行任务，以后每2秒执行一次</div><div class="line">        schedulePool.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(&quot;爆炸&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;, 5, 2, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ScheduledThreadPool</code>可以定时的或延时的执行任务。</p>
<p>Java的并发包很强大，上面所说只是入门，随着学习深入，会有更多记录在博客里。<br>本文来自：高爽|Coder，原文地址：<a href="http://blog.csdn.net/ghsau/article/details/7443324" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/7443324</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细介绍了 Java 开发中多线程的相关知识，并列举了常用的线程池。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://chuanqiang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java 基础" scheme="http://chuanqiang.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://chuanqiang.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker 基础</title>
    <link href="http://chuanqiang.github.io/2017/02/20/freemarker/"/>
    <id>http://chuanqiang.github.io/2017/02/20/freemarker/</id>
    <published>2017-02-20T13:28:44.000Z</published>
    <updated>2017-02-20T13:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细讲解了 FreeMarker 的使用和相关的语法。</p>
<a id="more"></a>
<h2 id="jsp-freemarker-velocity-比较"><a href="#jsp-freemarker-velocity-比较" class="headerlink" title="jsp freemarker velocity 比较"></a>jsp freemarker velocity 比较</h2><p>在 Java 领域，表现层的技术主要有三种: jsp、freemarker、veloctity.</p>
<h3 id="jsp-最常用的技术"><a href="#jsp-最常用的技术" class="headerlink" title="jsp 最常用的技术"></a>jsp 最常用的技术</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>功能强大，可以写java代码</li>
<li>支持jsp标签（jsp tag）</li>
<li>支持表达式语言（el）</li>
<li>官方标准，用户群广，丰富的第三方jsp标签库</li>
<li>性能良好。jsp编译成class文件执行，有很好的性能表现</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>jsp没有明显缺点，非要挑点骨头那就是，由于可以编写java代码，如使用不当容易破坏mvc结构。</p>
<h3 id="velocity-较早期出现的用于替代jsp的模板语言"><a href="#velocity-较早期出现的用于替代jsp的模板语言" class="headerlink" title="velocity 较早期出现的用于替代jsp的模板语言"></a>velocity 较早期出现的用于替代jsp的模板语言</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>不能编写java代码，可以实现严格的mvc分离</li>
<li>性能良好，据说比jsp性能还要好些</li>
<li>使用表达式语言，据说jsp的表达式语言就是学velocity的<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>不是官方标准</li>
<li>用户群体和第三方标签库没有jsp多。</li>
<li>对jsp标签支持不够好</li>
</ol>
<h3 id="freemarker"><a href="#freemarker" class="headerlink" title="freemarker"></a>freemarker</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>不能编写java代码，可以实现严格的mvc分离</li>
<li>性能非常不错</li>
<li>对jsp标签支持良好</li>
<li>内置大量常用功能，使用非常方便</li>
<li>宏定义（类似jsp标签）非常方便</li>
<li>使用表达式语言<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>不是官方标准</li>
<li>用户群体和第三方标签库没有jsp多</li>
</ol>
<h3 id="选择freemarker的原因"><a href="#选择freemarker的原因" class="headerlink" title="选择freemarker的原因"></a>选择freemarker的原因</h3><ol>
<li>性能。velocity应该是最好的，其次是jsp，普通的页面freemarker性能最差（虽然只是几毫秒到十几毫秒的差距）。但是在复杂页面上（包含大量判断、日期金额格式化）的页面上，freemarker的性能比使用tag和el的jsp好。</li>
<li>宏定义比jsp tag方便</li>
<li>内置大量常用功能。比如html过滤，日期金额格式化等等，使用非常方便</li>
<li>支持jsp标签</li>
<li>可以实现严格的mvc分离</li>
</ol>
<h2 id="FreeMarker-介绍"><a href="#FreeMarker-介绍" class="headerlink" title="FreeMarker 介绍"></a>FreeMarker 介绍</h2><p>FreeMarker是一款模板引擎：即一种基于模板、用来生成输出文本(任何来自于HTML格式的文本用来自动生成源代码)的通用工具。<br>使用MVC模式的动态页面的设计构思使得你可以将前端设计师(编写HTML页面的人员)从程序员中分离出来。</p>
<p>数据模型可以被看做是树状结构的。<br>标量存储单一的值，这种类型的值可以是字符串，数字，日期/时间或者是布尔值。<br>哈希表是存储变量和与其相关且有唯一标识名称变量的容器。<br>序列是存储有序变量的容器。存储的变量可以通过数字索引来检索，索引通常从零开始。</p>
<h3 id="模板一览"><a href="#模板一览" class="headerlink" title="模板一览"></a>模板一览</h3><p><code>${…}</code>：FreeMarker将会输出真实的值来替换花括号内的表达式<br>FTL tags 标签（FreeMarker模板的语言标签）：FTL标签和HTML标签有一点相似，但是它们是FreeMarker的指令而且是不会直接输出出来的东西。这些标签的使用一般以符号#开头<br>Comments注释：FreeMarker的注释和HTML的注释相似，但是它用&lt;#–和–&gt;来分隔的。<br>irectives指令：就是所指的FTL标签</p>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;#if ...&gt;</div><div class="line">	...</div><div class="line">&lt;#else&gt;</div><div class="line">	...</div><div class="line">&lt;#if&gt;</div></pre></td></tr></table></figure>
<h4 id="list-指令"><a href="#list-指令" class="headerlink" title="list 指令"></a>list 指令</h4><p>list指令的一般格式为：<br><code>&lt;#list sequence as loopVariable&gt;repeatThis&lt;/#list&gt;</code><br><code>repeatThis</code>部分将会在给定的<code>sequence</code>遍历时在每项中重复，从第一项开始，一个接着一个。在所有的重复中，<code>loopVariable</code>将持有当前项的值。这个循环变量仅存在于<code>&lt;#list …&gt;和&lt;/#list&gt;</code>标签之间。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;#list animals as being&gt;</div><div class="line">&lt;tr&gt;&lt;td&gt;$&#123;being.name&#125;&lt;td&gt;$&#123;being.price&#125; Euros</div><div class="line">&lt;/#list&gt;</div></pre></td></tr></table></figure></p>
<h4 id="include-指令"><a href="#include-指令" class="headerlink" title="include 指令"></a>include 指令</h4><p>在当前的模板中插入其他文件的内容。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">#include</span> "/<span class="attr">copyright_footer.html</span>"&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="处理不存在的变量"><a href="#处理不存在的变量" class="headerlink" title="处理不存在的变量"></a>处理不存在的变量</h4><p>一个不存在的变量和一个是null的变量，对于FreeMarker来说是一样的。此时，指定一个默认值来避免变量丢失这种情况。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">通过在变量名后面跟着一个!和默认值</div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome $&#123;user!"Anonymous"&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>也可以在变量名后面通过放置??来询问FreeMarker一个变量是否存在。将它和if指令合并，那么如果user变量不存在的话将会忽略整个问候代码段：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">#if</span> <span class="attr">user</span>??&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome $&#123;user&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">#if</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br>关于多级访问的变量不存在时<br><code>animals.python.price!0</code> 不存在时制定为0，但如果animals或者python不存在，那么模板处理过程将会以“未定义的变量”错误而停止。<br>可以这样来书写代码<code>(animals.python.price)!0</code>。这种情况下当animals或python不存在时表达式的结果仍然是0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;#assign seq = [&apos;a&apos;, &apos;b&apos;]&gt;</div><div class="line">$&#123;seq[0]!&apos;-&apos;&#125;</div><div class="line">$&#123;seq[1]!&apos;-&apos;&#125;</div><div class="line">$&#123;seq[2]!&apos;-&apos;&#125;</div><div class="line">$&#123;seq[3]!&apos;-&apos;&#125;</div></pre></td></tr></table></figure>
<p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a</div><div class="line">b</div><div class="line">-</div><div class="line">-</div></pre></td></tr></table></figure></p>
<h2 id="数值和类型"><a href="#数值和类型" class="headerlink" title="数值和类型"></a>数值和类型</h2><h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><ul>
<li>标量：<ul>
<li>字符串</li>
<li>数字</li>
<li>布尔值</li>
<li>日期</li>
</ul>
</li>
<li>容器：<ul>
<li>哈希表<br>  每个子变量都可以通过一个唯一的名称来查找（就像HashMap）</li>
<li>序列</li>
<li>集</li>
</ul>
</li>
<li>子程序：<ul>
<li>方法和函数</li>
<li>用户自定义指令</li>
</ul>
</li>
<li>其它/很少使用：</li>
<li>节点</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="1-总体结构"><a href="#1-总体结构" class="headerlink" title="1. 总体结构"></a>1. 总体结构</h3><p><strong>Text文本</strong>：文本会照着原样来输出。<br><strong>Interpolation插值</strong>：这部分的输出会被计算的值来替换。插值由${和}所分隔（或者#{和}，这种风格已经不建议再使用了）。<br><strong>FTL tags标签</strong>：FTL标签和HTML标签很相似，但是它们却是给FreeMarker的指示，而且不会打印在输出内容中。<br><strong>Comments注释</strong>：FTL的注释和HTML的注释也很相似，但它们是由&lt;#–和–&gt;来分隔的<br><img src="http://oeckzejn4.bkt.clouddn.com/blog/20161105-104618667.jpg" alt=""><br>FTL是区分大小写的.</p>
<h3 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2. 表达式"></a>2. 表达式</h3><ul>
<li>直接指定值<br> 字符串：”Foo” 或者 ‘Foo’ 或者 “It’s \”quoted\”” 或者 r”C:\raw\string”<br> 数字：123.45 &lt;#list[BR] animals as[BR] being[BR] &gt;[BR] ${being.name} for ${being.price} Euros[BR] &lt;/#list &gt;<br> 布尔值：true, false<br> 序列：[“foo”, “bar”, 123.45], 1..100<br> 哈希表：{“name”:”green mouse”, “price”:150}</li>
<li>检索变量<br> 顶层变量：user<br> 从哈希表中检索数据：user.name, user[“name”]<br> 从序列中检索：products[5]<br> 特殊变量：.main</li>
<li>字符串操作<br> 插值（或连接）：”Hello ${user}!”（或”Free” + “Marker”）<br> 获取一个字符：name[0]</li>
<li>序列操作<br> 连接：users + [“guest”]<br> 序列切分：products[10..19] 或 products[5..]</li>
<li>哈希表操作<br> 连接：passwords + {“joe”:”secret42”}</li>
<li>算数运算: (x * 1.5 + 10) / 2 - y % 100</li>
<li>比较运算：x == y, x != y, x &lt; y, x &gt; y, x &gt;= y, x &lt;= y, x &lt; y, 等等</li>
<li>逻辑操作：!registered &amp;&amp; (firstVisit || fromEurope)</li>
<li>内建函数：name?upper_case</li>
<li>方法调用：repeat(“What”, 3)</li>
<li>处理不存在的值<br> 默认值：name!”unknown” 或者(user.name)!”unknown” 或者name! 或者 (user.name)!<br> 检测不存在的值：name?? 或者(user.name)??</li>
</ul>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><table>
<thead>
<tr>
<th>转义序列</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td> \</td>
<td>引号（u0022）</td>
</tr>
<tr>
<td>\’</td>
<td>单引号（又称为撇号）（u0027）</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠（u005C）</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（u000A）</td>
</tr>
<tr>
<td>\r</td>
<td>回车（u000D）</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符（又称为标签）（u0009）</td>
</tr>
<tr>
<td>\b</td>
<td>退格（u0008）</td>
</tr>
<tr>
<td>\f</td>
<td>换页（u000C）</td>
</tr>
<tr>
<td>\l</td>
<td>小于号：&lt;</td>
</tr>
<tr>
<td>\g</td>
<td>大于号：&gt;</td>
</tr>
<tr>
<td>\a</td>
<td>和号：&amp;</td>
</tr>
<tr>
<td>\xCode</td>
<td>字符的16进制Unicode码（UCS码）</td>
</tr>
</tbody>
</table>
<h3 id="检索变量"><a href="#检索变量" class="headerlink" title="检索变量"></a>检索变量</h3><h4 id="在哈希表中检索数据"><a href="#在哈希表中检索数据" class="headerlink" title="在哈希表中检索数据"></a>在哈希表中检索数据</h4><p>(root)<br>|<br>+- book<br>| |<br>| +- title = “Breeding green mouses”<br>| |<br>| +- author<br>| |<br>| +- name = “Julia Smith”<br>| |<br>| +- info = “Biologist, 1923-1985, Canada”<br>|<br>+- test = “title”</p>
<p>下面这些示例它们含义都是相等的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">book.author.name, </div><div class="line">book[&quot;author&quot;].name, </div><div class="line">book.author.[&quot;name&quot;], </div><div class="line">book[&quot;author&quot;][&quot;name&quot;]</div></pre></td></tr></table></figure></p>
<h4 id="从序列中检索数据"><a href="#从序列中检索数据" class="headerlink" title="从序列中检索数据"></a>从序列中检索数据</h4><p>animals[0].name</p>
<h2 id="字符串和数值操作"><a href="#字符串和数值操作" class="headerlink" title="字符串和数值操作"></a>字符串和数值操作</h2><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>获取一个字符 <code>${str[0]}</code><br>获取一定范围的字符<code>substring</code></p>
<h4 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h4><p>加减乘数 （数字+字符=字符）<br>${100 – x*x}<br>${x/2}<br>${12%10}</p>
<p>只取整数部分的数值： ${(x/2)?int}<br><strong>比较操作</strong><br>相等：<code>=</code>或<code>==</code>无区别<br>不等：<code>!=</code><br>大于小于问题：FreeMarker解释<code>&gt;</code>的时候可以把它当作FTL标签的结束符。为了避免这种问题，不得不将表达式放到括号内：<code>&lt;#if (x &gt; y)&gt;</code>，或者可以在比较关系处使用<code>&amp;gt;</code>和<code>&amp;lt;</code></p>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>内建函数提供始终可用的内置功能。用<code>?</code>号来代替点。例如得到字符串的大写形式：<code>user?upper_case</code></p>
<ul>
<li>字符串使用的内建函数：<br> html: 字符串中所有的特殊HTML字符都需要用实体引用来代替（比如&lt;代替&lt;）。<br> cap_first:字符串的第一个字母变为大写形式<br> lower_case:字符串的小写形式<br> upper_case:字符串的大写形式<br> trim:去掉字符串首尾的空格</li>
<li>序列使用的内建函数：<br> size：序列中元素的个数</li>
<li>数字使用的内建函数：<br> int:数字的整数部分（比如-1.9?int就是-1）</li>
</ul>
<p><strong>方法调用：</strong><code>${repeat(&quot;What&quot;, 3)}</code></p>
<h3 id="操作符的优先级"><a href="#操作符的优先级" class="headerlink" title="操作符的优先级"></a>操作符的优先级</h3><table>
<thead>
<tr>
<th>运算符组</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>最高优先级运算符</td>
<td>[subvarName][subStringRange].?(methodParams) expr! expr??</td>
</tr>
<tr>
<td>一元前缀运算符</td>
<td>+expr -expr !expr</td>
</tr>
<tr>
<td>乘除法，求模</td>
<td>* / %</td>
</tr>
<tr>
<td>加减法</td>
<td>+ -</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&lt; &gt; &lt;= &gt;= (相当于: gt, lt, 等)</td>
</tr>
<tr>
<td>相等，不等</td>
<td>== (也可以是: =) !=</td>
</tr>
<tr>
<td>逻辑与</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>逻辑或</td>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td>数字范围</td>
<td>..</td>
</tr>
</tbody>
</table>
<p><strong>精确的转换规则</strong></p>
<ol>
<li>如果这个值是数字，那么它会按照指定的<code>number_format</code>设置规则来转换为字符串。所以这些转换通常是对用户进行的，而不是对计算机。</li>
<li>如果这个值是日期，时间或时间日期类型的一种，那么它们会按照指定的time_format，date_format和datetime_format设置规则来转换为字符串，这要看日期信息中是只包含时间，日期还是全包括了。如果它不能被探测出来是哪种日期类型（日期或时间或日期时间）时，就会发生错误了。</li>
<li>如果值本来就是字符串类型的，不需要转换。</li>
<li>如果FreeMarker引擎在传统兼容模式下：</li>
<li>如果值是布尔类型，那么就转换成<code>true</code>，false值将会转换为空串。</li>
<li>如果表达式未被定义（null或者变量未定义），那么就转换为空串。</li>
<li>否则就会发生错误中止模板执行。</li>
<li>否则就会发生错误中止模板执行。</li>
</ol>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h4 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h4><p>定义宏<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;#macro greet&gt;</div><div class="line">&lt;font size="+2"&gt;Hello Joe!&lt;/font&gt; （这个地方必须有加号）</div><div class="line">&lt;/#macro&gt;</div></pre></td></tr></table></figure></p>
<p>宏调用<br><code>&lt;@greet&gt;&lt;/@greet&gt;</code></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;#macro greet person&gt;</div><div class="line">&lt;font size="+2"&gt;Hello $&#123;person&#125;!&lt;/font&gt;</div><div class="line">&lt;/#macro&gt;</div><div class="line"></div><div class="line">&lt;@greet person="Fred"/&gt; and &lt;@greet person="Batman"/&gt;</div></pre></td></tr></table></figure>
<h4 id="嵌套内容"><a href="#嵌套内容" class="headerlink" title="嵌套内容"></a>嵌套内容</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;#macro border&gt;</div><div class="line">&lt;table border=4 cellspacing=0 cellpadding=4&gt;&lt;tr&gt;&lt;td&gt;</div><div class="line">&lt;#nested&gt;</div><div class="line">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</div><div class="line">&lt;/#macro&gt;</div></pre></td></tr></table></figure>
<p><code>&lt;#nested&gt;</code>指令执行位于开始和结束标记指令之间的模板代码段。（固定不变）</p>
<p>使用：<code>&lt;@border&gt;The bordered text&lt;/@border&gt;</code><br>效果：给<code>The bordered text</code>加了边框</p>
<p>在嵌套的内容中，宏的局部变量是不可变的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;#macro repeat count&gt;</div><div class="line">&lt;#local y = &quot;test&quot;&gt;</div><div class="line">&lt;#list 1..count as x&gt;</div><div class="line">$&#123;y&#125; $&#123;count&#125;/$&#123;x&#125;: &lt;#nested&gt;</div><div class="line">&lt;/#list&gt;</div><div class="line">&lt;/#macro&gt;</div><div class="line"></div><div class="line">&lt;@repeat count=3&gt;$&#123;y!&quot;?&quot;&#125; $&#123;x!&quot;?&quot;&#125; $&#123;count!&quot;?&quot;&#125;&lt;/@repeat&gt;</div></pre></td></tr></table></figure></p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test 3/1: ? ? ?</div><div class="line">test 3/2: ? ? ?</div><div class="line">test 3/3: ? ? ?</div></pre></td></tr></table></figure>
<h4 id="宏和循环变量"><a href="#宏和循环变量" class="headerlink" title="宏和循环变量"></a>宏和循环变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;#macro do_thrice&gt;</div><div class="line">&lt;#nested 1&gt;</div><div class="line">&lt;#nested 2&gt;</div><div class="line">&lt;#nested 3&gt;</div><div class="line">&lt;/#macro&gt;</div><div class="line">&lt;@do_thrice ; x&gt; &lt;#-- 用户自定义指令 使用&quot;;&quot;代替&quot;as&quot; --&gt;</div><div class="line">$&#123;x&#125; Anything.</div><div class="line">&lt;/@do_thrice&gt;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 Anything.</div><div class="line">2 Anything.</div><div class="line">3 Anything.</div></pre></td></tr></table></figure></p>
<h4 id="在模板中定义变量"><a href="#在模板中定义变量" class="headerlink" title="在模板中定义变量"></a>在模板中定义变量</h4><p>模板中变量的优先级 &gt; 数据模型中的。即 如果你恰巧定义了一个名为”foo”的变量，而在数据模型中也有一个名为”foo”的变量，那么模板中的变量就会将数据模型根上的变量隐藏（而不是覆盖！）。</p>
<p>在模板中可以定义三种类型的变量：</p>
<ul>
<li>简单变量：它能从模板中的任何位置来访问，或者从使用include指令引入的模板访问。可以使用assign或macro指令来创建或替换这些变量。</li>
<li>局部变量：它们只能被设置在宏定义体内，而且只在宏内可见。一个局部变量的生存周期只是宏的调用过程。可以使用local指令在宏定义体内创建或替换局部变量。</li>
<li>循环变量：循环变量是由指令（如list）自动创建的，而且它们只在指令的开始和结束标记内有效。宏的参数是局部变量而不是循环变量。</li>
</ul>
<p>使用assign创建和替换变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;#assign x = 1&gt; &lt;#-- 创建变量 x --&gt;</div><div class="line">$&#123;x&#125;</div><div class="line">&lt;#assign x = x + 3&gt; &lt;#-- 替换变量 x --&gt;</div><div class="line">$&#123;x&#125;</div></pre></td></tr></table></figure></p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p><strong>创建一个库</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;#macro copyright date&gt;</div><div class="line">&lt;p&gt;Copyright (C) $&#123;date&#125; Julia Smith. All rights reserved.&lt;/p&gt;</div><div class="line">&lt;/#macro&gt;</div><div class="line">&lt;#assign mail = &quot;jsmith@acme.com&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>把上面的这些定义存储在文件lib/my_test.ftl中<br>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;#import &quot;/lib/my_test.ftl&quot; as my&gt;</div><div class="line">&lt;#-- 被称为&quot;my&quot;的哈希表就会是那个&quot;大门&quot; --&gt;</div><div class="line">&lt;@my.copyright date=&quot;1999-2002&quot;/&gt;</div><div class="line">$&#123;my.mail&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><ol>
<li><code>${(user.name)!&quot;&quot;}</code>： <code>user.name</code> 为<code>null</code>的时候赋值为空字符串<code>&quot; &quot;</code>；</li>
<li><code>${user.name?string(&quot;0.##&quot;)}</code>: <code>user.name</code>不为<code>&quot;&quot;</code>时按保留两位小数的格式格式化</li>
</ol>
<h4 id="List-lt-Object-gt-转化为List-lt-Map-lt-String-String-gt-gt-数据后传至前台模板输出"><a href="#List-lt-Object-gt-转化为List-lt-Map-lt-String-String-gt-gt-数据后传至前台模板输出" class="headerlink" title="List&lt;Object&gt;转化为List&lt;Map&lt;String,String&gt;&gt;数据后传至前台模板输出"></a><code>List&lt;Object&gt;</code>转化为<code>List&lt;Map&lt;String,String&gt;&gt;</code>数据后传至前台模板输出</h4><p>转化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; getAllCountryOrder() &#123;</div><div class="line">    List&lt;CountryCode&gt; countrycodeList = countryInterface.getAllCountryCode(<span class="string">""</span>);</div><div class="line"></div><div class="line">    List&lt;Map&lt;String, String&gt;&gt; countryMapList = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, String&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (CountryCode countrycode : countrycodeList) &#123;</div><div class="line">        Map&lt;String, String&gt; tempMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(countrycode.getCode())) &#123;</div><div class="line">            tempMap.put(countrycode.getCode(), countrycode.getChineseName());</div><div class="line">        &#125;</div><div class="line">        countryMapList.add(tempMap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> countryMapList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>传至前台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">model.addAttribute(<span class="string">"countryList"</span>, countryCodeUtil.getAllCountryOrder());<span class="comment">// 项目所在国</span></div></pre></td></tr></table></figure></p>
<p>前台freemarker模板输出<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-left"</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"countrySelect"</span> <span class="attr">name</span>=<span class="string">"countryCode"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span> <span class="tag">&lt;<span class="name">#list</span> <span class="attr">countryList</span> <span class="attr">as</span> <span class="attr">countryMap</span>&gt;</span> <span class="tag">&lt;<span class="name">#list</span> <span class="attr">countryMap</span>?<span class="attr">keys</span> <span class="attr">as</span> <span class="attr">countryCode</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"$&#123;countryCode&#125;"</span>&gt;</span>$&#123;countryMap[countryCode]&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="tag">&lt;/<span class="name">#list</span>&gt;</span> <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细讲解了 FreeMarker 的使用和相关的语法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://chuanqiang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="freemarker" scheme="http://chuanqiang.github.io/tags/freemarker/"/>
    
  </entry>
  
  <entry>
    <title>常用 Git 命令清单</title>
    <link href="http://chuanqiang.github.io/2017/01/07/git-command/"/>
    <id>http://chuanqiang.github.io/2017/01/07/git-command/</id>
    <published>2017-01-07T14:15:49.000Z</published>
    <updated>2017-01-07T14:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了常用的 Git 命令清单，以供查阅复习。</p>
<p><img src="/image/code/Git/21.png" alt=""></p>
<a id="more"></a>
<hr>
<p>几个专有的名词译名如下:</p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><p>  在当前目录新建一个Git代码库<br> $ git init</p>
<p>  新建一个目录，将其初始化为Git代码库<br> $ git init [project-name]</p>
<p>  下载一个项目和它的整个代码历史<br> $ git clone [url]</p>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<p> 显示当前的Git配置<br> $ git config –list</p>
<p>  编辑Git配置文件<br> $ git config -e [–global]</p>
<p>  设置提交代码时的用户信息<br> $ git config [–global] user.name “[name]”<br> $ git config [–global] user.email “[email address]”</p>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><p> 添加指定文件到暂存区<br> $ git add [file1] [file2] …</p>
<p>  添加指定目录到暂存区，包括子目录<br> $ git add [dir]</p>
<p>  添加当前目录的所有文件到暂存区<br> $ git add .</p>
<p>  添加每个变化前，都会要求确认<br>  对于同一个文件的多处变化，可以实现分次提交<br> $ git add -p</p>
<p>  删除工作区文件，并且将这次删除放入暂存区<br> $ git rm [file1] [file2] …</p>
<p>  停止追踪指定文件，但该文件会保留在工作区<br> $ git rm –cached [file]</p>
<p>  改名文件，并且将这个改名放入暂存区<br> $ git mv [file-original] [file-renamed]</p>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><p>提交暂存区到仓库区<br> $ git commit -m [message]</p>
<p>  提交暂存区的指定文件到仓库区<br> $ git commit [file1] [file2] … -m [message]</p>
<p>  提交工作区自上次commit之后的变化，直接到仓库区<br> $ git commit -a</p>
<p>  提交时显示所有diff信息<br> $ git commit -v</p>
<p>  使用一次新的commit，替代上一次提交<br>  如果代码没有任何新变化，则用来改写上一次commit的提交信息<br> $ git commit –amend -m [message]</p>
<p>  重做上一次commit，并包括指定文件的新变化<br> $ git commit –amend [file1] [file2] …</p>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><p>列出所有本地分支<br> $ git branch</p>
<p>  列出所有远程分支<br> $ git branch -r</p>
<p>  列出所有本地分支和远程分支<br> $ git branch -a</p>
<p>  新建一个分支，但依然停留在当前分支<br> $ git branch [branch-name]</p>
<p>  新建一个分支，并切换到该分支<br> $ git checkout -b [branch]</p>
<p>  新建一个分支，指向指定commit<br> $ git branch [branch] [commit]</p>
<p>  新建一个分支，与指定的远程分支建立追踪关系<br> $ git branch –track [branch] [remote-branch]</p>
<p>  切换到指定分支，并更新工作区<br> $ git checkout [branch-name]</p>
<p>  切换到上一个分支<br> $ git checkout -</p>
<p>  建立追踪关系，在现有分支与指定的远程分支之间<br> $ git branch –set-upstream [branch] [remote-branch]</p>
<p>  合并指定分支到当前分支<br> $ git merge [branch]</p>
<p>  选择一个commit，合并进当前分支<br> $ git cherry-pick [commit]</p>
<p>  删除分支<br> $ git branch -d [branch-name]</p>
<p>  删除远程分支<br> $ git push origin –delete [branch-name]<br> $ git branch -dr [remote/branch]</p>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><p>列出所有tag<br> $ git tag</p>
<p>  新建一个tag在当前commit<br> $ git tag [tag]</p>
<p>  新建一个tag在指定commit<br> $ git tag [tag] [commit]</p>
<p>  删除本地tag<br> $ git tag -d [tag]</p>
<p>  删除远程tag<br> $ git push origin :refs/tags/[tagName]</p>
<p>  查看tag信息<br> $ git show [tag]</p>
<p>  提交指定tag<br> $ git push [remote] [tag]</p>
<p>  提交所有tag<br> $ git push [remote] –tags</p>
<p>  新建一个分支，指向某个tag<br> $ git checkout -b [branch] [tag]</p>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><p>显示有变更的文件<br> $ git status</p>
<p>  显示当前分支的版本历史<br> $ git log</p>
<p>  显示commit历史，以及每次commit发生变更的文件<br> $ git log –stat</p>
<p>  搜索提交历史，根据关键词<br> $ git log -S [keyword]</p>
<p>  显示某个commit之后的所有变动，每个commit占据一行<br> $ git log [tag] HEAD –pretty=format:%s</p>
<p>  显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件<br> $ git log [tag] HEAD –grep feature</p>
<p>  显示某个文件的版本历史，包括文件改名<br> $ git log –follow [file]<br> $ git whatchanged [file]</p>
<p>  显示指定文件相关的每一次diff<br> $ git log -p [file]</p>
<p>  显示过去5次提交<br> $ git log -5 –pretty –oneline</p>
<p>  显示所有提交过的用户，按提交次数排序<br> $ git shortlog -sn</p>
<p>  显示指定文件是什么人在什么时间修改过<br> $ git blame [file]</p>
<p>  显示暂存区和工作区的差异<br> $ git diff</p>
<p>  显示暂存区和上一个commit的差异<br> $ git diff –cached [file]</p>
<p>  显示工作区与当前分支最新commit之间的差异<br> $ git diff HEAD</p>
<p>  显示两次提交之间的差异<br> $ git diff [first-branch]…[second-branch]</p>
<p>  显示今天你写了多少行代码<br> $ git diff –shortstat “@{0 day ago}”</p>
<p>  显示某次提交的元数据和内容变化<br> $ git show [commit]</p>
<p>  显示某次提交发生变化的文件<br> $ git show –name-only [commit]</p>
<p>  显示某次提交时，某个文件的内容<br> $ git show [commit]:[filename]</p>
<p>  显示当前分支的最近几次提交<br> $ git reflog</p>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><p>下载远程仓库的所有变动<br> $ git fetch [remote]</p>
<p>  显示所有远程仓库<br> $ git remote -v</p>
<p>  显示某个远程仓库的信息<br> $ git remote show [remote]</p>
<p>  增加一个新的远程仓库，并命名<br> $ git remote add [shortname] [url]</p>
<p>  取回远程仓库的变化，并与本地分支合并<br> $ git pull [remote] [branch]</p>
<p>  上传本地指定分支到远程仓库<br> $ git push [remote] [branch]</p>
<p>  强行推送当前分支到远程仓库，即使有冲突<br> $ git push [remote] –force</p>
<p>  推送所有分支到远程仓库<br> $ git push [remote] –all</p>
<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><p>恢复暂存区的指定文件到工作区<br> $ git checkout [file]</p>
<p>  恢复某个commit的指定文件到暂存区和工作区<br> $ git checkout [commit] [file]</p>
<p>  恢复暂存区的所有文件到工作区<br> $ git checkout .</p>
<p>  重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br> $ git reset [file]</p>
<p>  重置暂存区与工作区，与上一次commit保持一致<br> $ git reset –hard</p>
<p>  重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br> $ git reset [commit]</p>
<p>  重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br> $ git reset –hard [commit]</p>
<p>  重置当前HEAD为指定commit，但保持暂存区和工作区不变<br> $ git reset –keep [commit]</p>
<p>  新建一个commit，用来撤销指定commit<br>  后者的所有变化都将被前者抵消，并且应用到当前分支<br> $ git revert [commit]</p>
<p>  暂时将未提交的变化移除，稍后再移入<br> $ git stash<br> $ git stash pop</p>
<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><p>生成一个可供发布的压缩包<br> $ git archive</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理了常用的 Git 命令清单，以供查阅复习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/code/Git/21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://chuanqiang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="http://chuanqiang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="http://chuanqiang.github.io/2017/01/02/Git/"/>
    <id>http://chuanqiang.github.io/2017/01/02/Git/</id>
    <published>2017-01-02T05:00:57.000Z</published>
    <updated>2017-01-05T13:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 Git教程的学习笔记，教程源自<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰</a>的博客。这是一个由浅入深，学完后能立刻上手的Git教程。<br>另，附上另一本优秀的Git书籍的中文版:<a href="https://git-scm.com/book/en/v2" target="_blank" rel="external">『Pro Git』</a>.</p>
<a id="more"></a>
<hr>
<h2 id="一、Git简介"><a href="#一、Git简介" class="headerlink" title="一、Git简介"></a>一、Git简介</h2><p><strong>Git是什么</strong>:Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br><strong>什么是版本控制系统</strong>:版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h3 id="集中式-vs分布式"><a href="#集中式-vs分布式" class="headerlink" title="集中式 vs分布式"></a>集中式 vs分布式</h3><p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？<br><strong>集中式版本控制系统</strong>:版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，每个人电脑上都有一个完整的版本库然后开始干活，干完活了，再把自己的活推送给中央服务器。<br><img src="/image/code/Git/01.jpg" alt=""><br><strong>分布式版本控制系统</strong>:每个人的电脑里有完整的版本库，统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br><img src="/image/code/Git/02.jpg?r=85" alt=""></p>
<h2 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h2><h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git</div><div class="line">The program &apos;git&apos; is currently not installed. You can install it by typing:</div><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure>
<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。<br>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把<code>GNU Interactive Tools</code>改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。<br>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p>
<h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>如果你正在使用Mac做开发，有两种安装Git的方法。<br>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/" target="_blank" rel="external">http://brew.sh/</a>。<br>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择『Command Line Tools』，点『Install』就可以完成安装了。<br><img src="/image/code/Git/03.jpg" alt=""><br>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p>
<h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p><a href="https://git-scm.com/" target="_blank" rel="external">Git官网</a><br>msysgit是Windows版的Git，从<a href="https://git-for-windows.github.io/" target="_blank" rel="external">https://git-for-windows.github.io</a>下载（网速慢的同学请移步<a href="https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit" target="_blank" rel="external">国内镜像</a>），然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Your Name&quot;</div><div class="line">$ git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。<br>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="三、创建版本库"><a href="#三、创建版本库" class="headerlink" title="三、创建版本库"></a>三、创建版本库</h2><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<h4 id="1-创建一个版本库"><a href="#1-创建一个版本库" class="headerlink" title="1.创建一个版本库:"></a>1.创建一个版本库:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mkdir learngit</div><div class="line">$ cd learngit</div><div class="line">$ pwd</div><div class="line">/d/zcq</div></pre></td></tr></table></figure>
<p><strong>注意</strong>:<code>pwd</code>命令用于显示当前目录。目录中最好不包含中文。</p>
<h4 id="2-通过-git-init-命令把这个目录变成Git可以管理的仓库："><a href="#2-通过-git-init-命令把这个目录变成Git可以管理的仓库：" class="headerlink" title="2.通过 git init 命令把这个目录变成Git可以管理的仓库："></a>2.通过 git init 命令把这个目录变成Git可以管理的仓库：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">Initialized empty Git repository in D:/zcq/learngit/.git/</div></pre></td></tr></table></figure>
<p>这样一个仓库就建好了，而且告诉你是一个空的仓库（empty Git repository），而且当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等。版本控制系统可以告诉你每次的改动，而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的<strong>UTF-8</strong>编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。<br><strong>注意</strong>:不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="external">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为<code>UTF-8 without BOM</code>即可。</p>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ol>
<li>编写一个<code>readme.txt</code>文件</li>
<li>用命令<code>git add</code>告诉Git，把文件添加到仓库：<code>git add readme.txt</code></li>
<li>用命令<code>git commit</code>告诉Git，把文件提交到仓库：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;wrote a readme file&quot;</div><div class="line">[master (root-commit) cb926e7] wrote a readme file</div><div class="line"> 1 file changed, 2 insertions(+)</div><div class="line"> create mode 100644 readme.txt</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意:</strong><code>-m</code>后面输入的是本次提交的说明。<code>commit</code>可以一次提交多次文件</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：<br>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br>第二步，使用命令<code>git commit</code>，完成。</p>
<h2 id="四、版本库操作"><a href="#四、版本库操作" class="headerlink" title="四、版本库操作"></a>四、版本库操作</h2><ul>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
</ul>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul>
<li><code>git log</code>:查看版本库状态(版本提交日志)</li>
<li><code>git log --pretty=oneline</code>:简化显示提交日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git log --pretty=oneline</div><div class="line">a1e1f505c25e19b240edcc9b0b2d75f9be354310 hello world</div><div class="line">3ff7fa95a24507440f8f334630b4d5d31f0687c2 add words</div><div class="line">ad822b5889999039e1fce221092d142bd6057b0c change readme.txt</div></pre></td></tr></table></figure>
</li>
</ul>
<p>前面那一串字符是<code>commit id</code>(版本号)，和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。防止冲突。</p>
<ul>
<li><code>git reset</code>:回退到上一个版本<ul>
<li><code>HEAD</code>表示当前版本，上一个版本是<code>HEAD^</code>，上上个版本是<code>HEAD^^</code>，网上100个版本是<code>HEAD~100</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard HEAD^</div><div class="line">HEAD is now at ea34578 add distributed</div></pre></td></tr></table></figure>
<p>回退后查看readme.txt的内容是不是已经回退:<code>cat readme.txt</code><br>回退之后想要再恢复:<code>git reflog</code>用来记录你的每一次命令，执行后找到回退前的那个版本的<code>commit id</code>(或者在命令行里找到)，就可以制定恢复到回退前的版本(id的前几位就行):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard 3628164</div><div class="line">HEAD is now at 3628164 append GPL</div></pre></td></tr></table></figure></p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把<code>HEAD</code>从指向那一版本。然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br><strong>工作区</strong>（Working Directory）:电脑里能看到的目录</p>
<p><strong>版本库</strong>（Repository）:工作区中有一个隐藏目录<code>.git</code>时，为Git的版本库<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向master的一个指针叫<code>HEAD</code>。<br><img src="/image/code/Git/04.jpg" alt=""></p>
<ul>
<li>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>
<li>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</li>
</ul>
<p><strong>eg:</strong><br>1.添加两个文件<code>readme.txt</code>和<code>LICENSE</code>.使用两次<code>git add</code>添加后，使用<code>git status</code>查看一下，暂存区的状态如下:<br><img src="/image/code/Git/05.jpg" alt=""><br>2.执行<code>git commit</code>命令后，你又没有对工作区做任何修改，那么工作区就是『干净』的。暂存区现在的状态如下:<br><img src="/image/code/Git/06.jpg" alt=""></p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。<br>比如，你第一次修改了文件，<code>git add</code>,第二次又修改了文件，没有<code>git add</code>，然后<code>git commit</code>。此时，第二次的修改不会提交，因为第二次的修改没有提交到缓存区。<br><code>git diff HEAD -- readme.txt</code>:查看工作区和版本库里面最新版本的区别。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="1-撤销工作区的修改"><a href="#1-撤销工作区的修改" class="headerlink" title="1. 撤销工作区的修改"></a>1. 撤销工作区的修改</h4><p><code>git checkout -- readme.txt</code>:把文件<code>readme.txt</code>在工作区的修改全部撤销。分两种情况<br>  一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>  一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。  </p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了『切换到另一个分』的命令。</p>
<h4 id="2-撤销已到缓存区的修改"><a href="#2-撤销已到缓存区的修改" class="headerlink" title="2. 撤销已到缓存区的修改"></a>2. 撤销已到缓存区的修改</h4><p>当修改的文件已经提交的缓存区，想撤销时:<code>git reset HEAD file</code>。</p>
<ul>
<li><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEA</code>D时，表示最新的版本。</li>
</ul>
<h4 id="3-撤销提交到版本库的修改"><a href="#3-撤销提交到版本库的修改" class="headerlink" title="3. 撤销提交到版本库的修改"></a>3. 撤销提交到版本库的修改</h4><p>如果没有把本地版本库推送到远程，可以使用版本回退<code>git reset --hard commit_id</code>。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>用<code>rm test.txt</code>命令删除文件后，如果确实要从版本库删除该文件:<code>git rm test.txt</code>;如果删错了:<code>git checkout -- test.txt</code><br><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h2 id="五、远程仓库"><a href="#五、远程仓库" class="headerlink" title="五、远程仓库"></a>五、远程仓库</h2><h3 id="使用-Github-作为远程仓库"><a href="#使用-Github-作为远程仓库" class="headerlink" title="使用 Github 作为远程仓库"></a>使用 Github 作为远程仓库</h3><p><strong>第1步</strong>：创建SSH Key。在用户主目录下(我的:C:\Users\zcq12.ssh)，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</div></pre></td></tr></table></figure></p>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p><strong>第2步</strong>：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的Key。</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。<br>GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。<br><strong>提示</strong></p>
<ul>
<li>在GitHub上免费托管的Git仓库，任何人都可以看到。</li>
<li>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的</li>
<li>另一个办法是自己动手，搭一个Git服务器</li>
</ul>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><ol>
<li>登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。</li>
<li>GitHub会提示如何从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后把本地仓库的内容推送到GitHub仓库。</li>
</ol>
<p><img src="/image/code/Git/07.png?r=100" alt=""><br><strong>注:</strong>由于远程库是空的，我们第一次推送master分支时，加上了<code>-u</code>参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>此时，本地提交后，就可以通过命令<code>$ git push origin master</code>，把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>先创建远程库，然后克隆远程库。<br><img src="/image/code/Git/08.png" alt=""><br>复制下你远程库的地址，用命令<code>git clone</code>克隆一个本地库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/chuanqiang/learngit.git</div><div class="line">Cloning into &apos;learngit&apos;...</div><div class="line">remote: Counting objects: 12, done.</div><div class="line">remote: Compressing objects: 100% (5/5), done.</div><div class="line">remote: Total 12 (delta 0), reused 12 (delta 0), pack-reused 0</div><div class="line">Receiving objects: 100% (12/12), done.</div></pre></td></tr></table></figure></p>
<p>进入目录，就可以看到克隆到本地的库了。<br><strong>注意</strong>:</p>
<ul>
<li>GitHub给出的地址不止一个，还可以用<code>$ git clone git@github.com:chuanqiang/learngit.git</code>这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</li>
<li>使用https除了速度慢以外，还有个问题是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li>
<li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li>
<li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li>
<li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</li>
<li>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</li>
</ul>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。</p>
<h2 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h2><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。HEAD严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：<br><img src="/image/code/Git/09.jpg" alt=""><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：</p>
<p><img src="/image/code/Git/10.jpg" alt=""><br>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向dev，就表示当前分支在<code>dev</code>上：<br><img src="/image/code/Git/11.jpg" alt=""><br>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>maste</code>r指针不变：<br><img src="/image/code/Git/12.jpg" alt=""><br>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img src="/image/code/Git/13.jpg" alt=""><br>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="/image/code/Git/14.jpg" alt=""></p>
<h4 id="1-实战"><a href="#1-实战" class="headerlink" title="1. 实战"></a>1. 实战</h4><p>1.创建<code>dev</code>分支，并切换到<code>dev</code>分支:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch &apos;dev&apos;</div></pre></td></tr></table></figure></p>
<p><code>git checkout</code>加上<code>-b</code>表示创建并切换，相当于以下两天命令:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line">$ git checkout dev</div></pre></td></tr></table></figure></p>
<p>2.用<code>git branch</code>查看当前分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* dev</div><div class="line">  master</div></pre></td></tr></table></figure></p>
<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。<br>然后，我们就可以在<code>dev</code>分支上正常提交.</p>
<p>3.<code>dev</code>分支完成后，就可以切换回<code>master</code>分支:<code>$ git checkout master</code>。切换回来后发现刚才修改的内容不见了。因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点没有变。</p>
<p><img src="/image/code/Git/15.jpg" alt=""><br>4.把<code>dev</code>分支合并到<code>master</code>分支上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git merge dev</div><div class="line">Updating c42af54..150542d</div><div class="line">Fast-forward</div><div class="line"> readme.txt | 4 +++-</div><div class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</div></pre></td></tr></table></figure></p>
<p><code>git merge</code>命令用于合并指定分支到当前分支。注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>5.合并完成后，就可以放心的删除<code>dev</code>分支了:<code>git branch -d dev</code>.删除后<code>git branch</code>查看，就只剩下<code>master</code>分支了。</p>
<h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h4><p>Git鼓励大量使用分支：<br>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b feature1</div><div class="line">Switched to a new branch &apos;feature1&apos;</div></pre></td></tr></table></figure></p>
<p>修改<code>readme.txt</code>最后一行，改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick AND simple.</div></pre></td></tr></table></figure></p>
<p>在<code>feature1</code>分支上提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt </div><div class="line">$ git commit -m &quot;AND simple&quot;</div><div class="line">[feature1 75a857c] AND simple</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div></pre></td></tr></table></figure></p>
<p>切换到<code>master</code>分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div><div class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</div></pre></td></tr></table></figure></p>
<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick &amp; simple.</div></pre></td></tr></table></figure></p>
<p>提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt </div><div class="line">$ git commit -m &quot;&amp; simple&quot;</div><div class="line">[master 400b400] &amp; simple</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div></pre></td></tr></table></figure></p>
<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：<br><img src="/image/code/Git/16.png" alt=""><br>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge feature1</div><div class="line">Auto-merging readme.txt</div><div class="line">CONFLICT (content): Merge conflict in readme.txt</div><div class="line">Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>
<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"># On branch master</div><div class="line"># Your branch is ahead of &apos;origin/master&apos; by 2 commits.</div><div class="line">#</div><div class="line"># Unmerged paths:</div><div class="line">#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)</div><div class="line">#</div><div class="line">#       both modified:      readme.txt</div><div class="line">#</div><div class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</div></pre></td></tr></table></figure>
<p>我们可以直接查看<code>readme.txt</code>的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div><div class="line">Git tracks changes of files.</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">Creating a new branch is quick &amp; simple.</div><div class="line">=======</div><div class="line">Creating a new branch is quick AND simple.</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</div></pre></td></tr></table></figure>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick and simple.</div></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt </div><div class="line">$ git commit -m &quot;conflict fixed&quot;</div><div class="line">[master 59bc1cb] conflict fixed</div></pre></td></tr></table></figure>
<p>现在，master分支和feature1分支变成了下图所示：</p>
<p><img src="/image/code/Git/17.png" alt=""><br>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div><div class="line">*   59bc1cb conflict fixed</div><div class="line">|\</div><div class="line">| * 75a857c AND simple</div><div class="line">* | 400b400 &amp; simple</div><div class="line">|/</div><div class="line">* fec145a branch test</div><div class="line">...</div></pre></td></tr></table></figure>
<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -d feature1</div><div class="line">Deleted branch feature1 (was 75a857c).</div></pre></td></tr></table></figure>
<p>工作完成。</p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<br>下面我们实战一下–no-ff方式的git merge：<br>首先，仍然创建并切换dev分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch &apos;dev&apos;</div></pre></td></tr></table></figure>
<p>修改<code>readme.txt</code>文件，并提交一个新的<code>commit</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt </div><div class="line">$ git commit -m &quot;add merge&quot;</div><div class="line">[dev 6224937] add merge</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure>
<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div></pre></td></tr></table></figure>
<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</div><div class="line">Merge made by the &apos;recursive&apos; strategy.</div><div class="line"> readme.txt |    1 +</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure>
<p>因为本次合并要创建一个新的<code>commit</code>，所以加上<code>-m</code>参数，把<code>commit</code>描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div><div class="line">*   7825a50 merge with no-ff</div><div class="line">|\</div><div class="line">| * 6224937 add merge</div><div class="line">|/</div><div class="line">*   59bc1cb conflict fixed</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看到，不使用<code>Fast forward</code>模式，<code>merge</code>后就像这样：</p>
<p><img src="/image/code/Git/18.png" alt=""></p>
<h4 id="1-分支策略"><a href="#1-分支策略" class="headerlink" title="1. 分支策略"></a>1. 分支策略</h4><p>在实际开发中，我们应该按照几个基本原则进行分支管理：<br>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；<br>所以，团队合作的分支看起来就像这样：</p>
<p><img src="/image/code/Git/19.png" alt=""></p>
<h4 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2. 小结"></a>2. 小结</h4><p>Git分支十分强大，在团队开发中应该充分应用。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<br>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git stash</div><div class="line">Saved working directory and index state WIP on dev: 6224937 add merge</div><div class="line">HEAD is now at 6224937 add merge</div></pre></td></tr></table></figure>
<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div><div class="line">Your branch is ahead of &apos;origin/master&apos; by 6 commits.</div><div class="line">$ git checkout -b issue-101</div><div class="line">Switched to a new branch &apos;issue-101&apos;</div></pre></td></tr></table></figure>
<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt </div><div class="line">$ git commit -m &quot;fix bug 101&quot;</div><div class="line">[issue-101 cc17032] fix bug 101</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div></pre></td></tr></table></figure>
<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div><div class="line">Your branch is ahead of &apos;origin/master&apos; by 2 commits.</div><div class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line">Merge made by the &apos;recursive&apos; strategy.</div><div class="line"> readme.txt |    2 +-</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div><div class="line">$ git branch -d issue-101</div><div class="line">Deleted branch issue-101 (was cc17032).</div></pre></td></tr></table></figure>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div><div class="line">Switched to branch &apos;dev&apos;</div><div class="line">$ git status</div><div class="line"># On branch dev</div><div class="line">nothing to commit (working directory clean)</div></pre></td></tr></table></figure>
<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div><div class="line">stash@&#123;0&#125;: WIP on dev: 6224937 add merge</div></pre></td></tr></table></figure>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把<code>stash</code>内容也删了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git stash pop</div><div class="line"># On branch dev</div><div class="line"># Changes to be committed:</div><div class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line">#</div><div class="line">#       new file:   hello.py</div><div class="line">#</div><div class="line"># Changes not staged for commit:</div><div class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line">#</div><div class="line">#       modified:   readme.txt</div><div class="line">#</div><div class="line">Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</div></pre></td></tr></table></figure>
<p>再用git stash list查看，就看不到任何stash内容了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div></pre></td></tr></table></figure>
<p>你可以多次<code>stash</code>，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash apply stash@&#123;0&#125;</div></pre></td></tr></table></figure>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<h3 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h3><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个<code>feature</code>分支，在上面开发，完成后，合并，最后，删除该<code>feature</code>分支。<br>接到新任务后，准备开发:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b feature-vulcan</div><div class="line">Switched to a new branch &apos;feature-vulcan&apos;</div></pre></td></tr></table></figure></p>
<p>开发完毕：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git add vulcan.py</div><div class="line">$ git status</div><div class="line"># On branch feature-vulcan</div><div class="line"># Changes to be committed:</div><div class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line">#</div><div class="line">#       new file:   vulcan.py</div><div class="line">#</div><div class="line">$ git commit -m &quot;add feature vulcan&quot;</div><div class="line">[feature-vulcan 756d4af] add feature vulcan</div><div class="line"> 1 file changed, 2 insertions(+)</div><div class="line"> create mode 100644 vulcan.py</div></pre></td></tr></table></figure>
<p>切回<code>dev</code>，准备合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div></pre></td></tr></table></figure>
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>但是，就在此时，接到上级命令，因经费不足，新功能必须取消！这个分支还是必须就地销毁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch -d feature-vulcan</div><div class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</div><div class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</div></pre></td></tr></table></figure>
<p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令<code>git branch -D feature-vulcan</code>。</p>
<p>现在我们强行删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -D feature-vulcan</div><div class="line">Deleted branch feature-vulcan (was 756d4af).</div></pre></td></tr></table></figure>
<p>终于删除成功！</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>开发一个新<code>feature</code>，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。<br>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure>
<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</div><div class="line">origin  git@github.com:michaelliao/learngit.git (push)</div></pre></td></tr></table></figure>
<p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<h4 id="1-推送分支"><a href="#1-推送分支" class="headerlink" title="1. 推送分支"></a>1. 推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<h4 id="2-抓取分支"><a href="#2-抓取分支" class="headerlink" title="2. 抓取分支"></a>2. 抓取分支</h4><p>多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</li>
</ol>
<p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h4><ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用git pull抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<h2 id="七、标签管理"><a href="#七、标签管理" class="headerlink" title="七、标签管理"></a>七、标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。(版本库和标签类似于IP和域名的关系，域名好记)</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* dev</div><div class="line">  master</div><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div></pre></td></tr></table></figure></p>
<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v1.0</div></pre></td></tr></table></figure>
<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line">v1.0</div></pre></td></tr></table></figure>
<p>默认标签是打在最新提交的<code>commit</code>上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的<code>commit id</code>，然后打上就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git log --pretty=oneline --abbrev-commit</div><div class="line">6a5819e merged bug fix 101</div><div class="line">cc17032 fix bug 101</div><div class="line">7825a50 merge with no-ff</div><div class="line">6224937 add merge</div><div class="line">59bc1cb conflict fixed</div><div class="line">400b400 &amp; simple</div><div class="line">75a857c AND simple</div><div class="line">fec145a branch test</div><div class="line">d17efd8 remove test.txt</div><div class="line">...</div></pre></td></tr></table></figure>
<p>比方说要对<code>add merge</code>这次提交打标签，它对应的<code>commit id</code>是6224937，敲入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v0.9 6224937</div></pre></td></tr></table></figure>
<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line">v0.9</div><div class="line">v1.0</div></pre></td></tr></table></figure>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git show v0.9</div><div class="line">commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4</div><div class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</div><div class="line">Date:   Thu Aug 22 11:22:08 2013 +0800</div><div class="line"></div><div class="line">    add merge</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看到，v0.9确实打在<code>add merge</code>这次提交上。</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164</div></pre></td></tr></table></figure>
<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git show v0.1</div><div class="line">tag v0.1</div><div class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</div><div class="line">Date:   Mon Aug 26 07:28:11 2013 +0800</div><div class="line"></div><div class="line">version 0.1 released</div><div class="line"></div><div class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</div><div class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</div><div class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</div><div class="line"></div><div class="line">    append GPL</div></pre></td></tr></table></figure>
<p>还可以通过<code>-s</code>用私钥签名一个标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a</div></pre></td></tr></table></figure>
<p>签名采用PGP签名，因此，必须首先安装<code>gpg</code>（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gpg: signing failed: secret key not available</div><div class="line">error: gpg failed to sign the data</div><div class="line">error: unable to sign the tag</div></pre></td></tr></table></figure>
<p>如果报错，请参考GnuPG帮助文档配置<code>Key</code>。</p>
<p>用命令<code>git show &lt;tagname&gt;</code>可以看到PGP签名信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ git show v0.2</div><div class="line">tag v0.2</div><div class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</div><div class="line">Date:   Mon Aug 26 07:28:33 2013 +0800</div><div class="line"></div><div class="line">signed version 0.2 released</div><div class="line">-----BEGIN PGP SIGNATURE-----</div><div class="line">Version: GnuPG v1.4.12 (Darwin)</div><div class="line"></div><div class="line">iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...</div><div class="line">-----END PGP SIGNATURE-----</div><div class="line"></div><div class="line">commit fec145accd63cdc9ed95a2f557ea0658a2a6537f</div><div class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</div><div class="line">Date:   Thu Aug 22 10:37:30 2013 +0800</div><div class="line"></div><div class="line">    branch test</div></pre></td></tr></table></figure>
<p>用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -d v0.1</div><div class="line">Deleted tag &apos;v0.1&apos; (was e078af9)</div></pre></td></tr></table></figure>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin v1.0</div><div class="line">Total 0 (delta 0), reused 0 (delta 0)</div><div class="line">To git@github.com:michaelliao/learngit.git</div><div class="line"> * [new tag]         v1.0 -&gt; v1.0</div></pre></td></tr></table></figure>
<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git push origin --tags</div><div class="line">Counting objects: 1, done.</div><div class="line">Writing objects: 100% (1/1), 554 bytes, done.</div><div class="line">Total 1 (delta 0), reused 0 (delta 0)</div><div class="line">To git@github.com:michaelliao/learngit.git</div><div class="line"> * [new tag]         v0.2 -&gt; v0.2</div><div class="line"> * [new tag]         v0.9 -&gt; v0.9</div></pre></td></tr></table></figure>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -d v0.9</div><div class="line">Deleted tag &apos;v0.9&apos; (was 6224937)</div></pre></td></tr></table></figure>
<p>然后，从远程删除。删除命令也是<code>push</code>，但是格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git push origin :refs/tags/v0.9</div><div class="line">To git@github.com:michaelliao/learngit.git</div><div class="line"> - [deleted]         v0.9</div></pre></td></tr></table></figure>
<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h2 id="八、使用GitHub"><a href="#八、使用GitHub" class="headerlink" title="八、使用GitHub"></a>八、使用GitHub</h2><p>bootstrap项目，这是一个非常强大的CSS框架，项目主页:<a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">https://github.com/twbs/bootstrap</a>，点右上角的『Fork』就在自己的账号下克隆了一个<code>bootstrap</code>仓库，然后，从自己的账号下<code>clone</code>。<br><strong>注</strong>:一定要从自己的账号下<code>clone</code>仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在GitHub上，可以任意<code>Fork</code>开源仓库；</li>
<li>自己拥有<code>Fork</code>后的仓库的读写权限；</li>
<li>可以推送<code>pull request</code>给官方仓库来贡献代码</li>
</ul>
<h2 id="九、自定义Git"><a href="#九、自定义Git" class="headerlink" title="九、自定义Git"></a>九、自定义Git</h2><h3 id="Git命令行显示颜色"><a href="#Git命令行显示颜色" class="headerlink" title="Git命令行显示颜色"></a>Git命令行显示颜色</h3><p><code>$ git config --global color.ui true</code></p>
<h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>举个例子：</p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Windows:</div><div class="line">Thumbs.db</div><div class="line">ehthumbs.db</div><div class="line">Desktop.ini</div></pre></td></tr></table></figure>
<p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Python:</div><div class="line">*.py[cod]</div><div class="line">*.so</div><div class="line">*.egg</div><div class="line">*.egg-info</div><div class="line">dist</div><div class="line">build</div></pre></td></tr></table></figure>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># Windows:</div><div class="line">Thumbs.db</div><div class="line">ehthumbs.db</div><div class="line">Desktop.ini</div><div class="line"></div><div class="line"># Python:</div><div class="line">*.py[cod]</div><div class="line">*.so</div><div class="line">*.egg</div><div class="line">*.egg-info</div><div class="line">dist</div><div class="line">build</div><div class="line"></div><div class="line"># My configurations:</div><div class="line">db.ini</div><div class="line">deploy_key_rsa</div></pre></td></tr></table></figure>
<p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add App.class</div><div class="line">The following paths are ignored by one of your .gitignore files:</div><div class="line">App.class</div><div class="line">Use -f if you really want to add them.</div></pre></td></tr></table></figure>
<p>如果你确实想添加该文件，可以用-f强制添加到Git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add -f App.class</div></pre></td></tr></table></figure>
<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git check-ignore -v App.class</div><div class="line">.gitignore:3:*.class    App.class</div></pre></td></tr></table></figure>
<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul>
<li>忽略某些文件时，需要编写<code>.gitignore</code>；</li>
<li><code>.gitignore</code>文件本身要放到版本库里，并且可以对.gitignore做版本管理！</li>
</ul>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>有没有经常敲错命令？比如<code>git status</code>？status这个单词真心不好记。<br>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure>
<p>好了，现在敲<code>git st</code>看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.co checkout</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.br branch</div></pre></td></tr></table></figure>
<p>以后提交就可以简写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git ci -m &quot;bala bala bala...&quot;</div></pre></td></tr></table></figure>
<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>比如命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.unstage &apos;reset HEAD&apos;</div></pre></td></tr></table></figure>
<p>当你敲入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git unstage test.py</div></pre></td></tr></table></figure>
<p>实际上Git执行的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD test.py</div></pre></td></tr></table></figure>
<p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.last &apos;log -1&apos;</div></pre></td></tr></table></figure>
<p>甚至还有人丧心病狂地把lg配置成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure>
<p>来看看git lg的效果：</p>
<p><img src="/image/code/Git/20.png" alt=""></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ cat .git/config </div><div class="line">[core]</div><div class="line">    repositoryformatversion = 0</div><div class="line">    filemode = true</div><div class="line">    bare = false</div><div class="line">    logallrefupdates = true</div><div class="line">    ignorecase = true</div><div class="line">    precomposeunicode = true</div><div class="line">[remote &quot;origin&quot;]</div><div class="line">    url = git@github.com:michaelliao/learngit.git</div><div class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</div><div class="line">[branch &quot;master&quot;]</div><div class="line">    remote = origin</div><div class="line">    merge = refs/heads/master</div><div class="line">[alias]</div><div class="line">    last = log -1</div></pre></td></tr></table></figure>
<p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat .gitconfig</div><div class="line">[alias]</div><div class="line">    co = checkout</div><div class="line">    ci = commit</div><div class="line">    br = branch</div><div class="line">    st = status</div><div class="line">[user]</div><div class="line">    name = Your Name</div><div class="line">    email = your@email.com</div></pre></td></tr></table></figure>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h3 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h3><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用<strong>Ubuntu</strong>或<strong>Debian</strong>，这样，通过几条简单的apt命令就可以完成安装。<br>假设你已经有sudo权限的用户账号，下面，正式开始安装。<br>第一步，安装git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git</div></pre></td></tr></table></figure>
<p>第二步，创建一个git用户，用来运行git服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo adduser git</div></pre></td></tr></table></figure>
<p>第三步，创建证书登录：</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id\_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized\_keys</code>文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在/srv目录下输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo git init --bare sample.git</div></pre></td></tr></table></figure>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo chown -R git:git sample.git</div></pre></td></tr></table></figure>
<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</div></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</div></pre></td></tr></table></figure>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的<code>git-shell</code>每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone git@server:/srv/sample.git</div><div class="line">Cloning into &apos;sample&apos;...</div><div class="line">warning: You appear to have cloned an empty repository.</div></pre></td></tr></table></figure>
<p>剩下的推送就简单了。</p>
<h3 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h3><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized\_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="external">Gitosis</a>来管理公钥。</p>
<p>这里我们不介绍怎么玩<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="external">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p>
<h3 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h3><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">Gitolite</a>就是这个工具。</p>
<p>这里我们也不介绍<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><ul>
<li>搭建Git服务器非常简单，通常10分钟即可完成；</li>
<li>要方便管理公钥，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">Gitosis</a>；</li>
<li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">Gitolite</a>。</li>
</ul>
<h2 id="十、Git命令速查表"><a href="#十、Git命令速查表" class="headerlink" title="十、Git命令速查表"></a>十、Git命令速查表</h2><p><img src="/image/code/Git/git命令速查表.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为 Git教程的学习笔记，教程源自&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰&lt;/a&gt;的博客。这是一个由浅入深，学完后能立刻上手的Git教程。&lt;br&gt;另，附上另一本优秀的Git书籍的中文版:&lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;『Pro Git』&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://chuanqiang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="http://chuanqiang.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
